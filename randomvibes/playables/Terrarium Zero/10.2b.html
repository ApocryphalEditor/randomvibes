<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Patch: v10.2 - Smaller About btn, updated title/tagline, +/- toggle icon for Story, tooltip review pass. -->
    <title>Terrarium Zero - Version 10.2</title>
    <style>
        /* --- CSS (Mostly Identical to 9.8/10.2html, includes smaller About button styles) --- */
        body { font-family: sans-serif; line-height: 1.5; padding: 15px; background-color: #f4f4f4; display: flex; flex-direction: column; min-height: 100vh; box-sizing: border-box; margin: 0; font-size: 14px }
        #mythographicBarCanvas { display: block; width: 100%; height: 50px; background-color: #ccc; border: 1px solid #888; margin-bottom: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #main-content { display: flex; flex-grow: 1; gap: 15px; overflow: hidden; margin-top: 10px }
        #left-column { flex: 0 0 320px; display: flex; flex-direction: column; gap: 12px; }
        #right-column { flex: 1; display: flex; flex-direction: column; overflow-y: auto; gap: 10px; padding-right: 5px; }
        #controls button, #story-mode-panel button {
            padding: 8px 12px;
            margin-right: 8px; /* spacing to the right */
            cursor: pointer;
            border: none;
            background-color: #5cb85c;
            color: #fff;
            border-radius: 4px;
            display: inline-block; /* Changed from block */
            /* width: 100%; */ /* Removed this line */
            margin-bottom: 5px; /* Spacing below (for wrapping) */
            font-size: .9em;
        }
        #controls button:disabled, #story-mode-panel button:disabled { background-color: #ccc; cursor: not-allowed }
        #stopButton { background-color: #d9534f }
        #spotlightButton { background-color: #46b8da }
        #saveReportButton { background-color: #f0ad4e; margin-top: 10px; color: #333; }
        #status, #environment-status, #population-stats, #major-events, #lifetime-stats, #spotlight-panel, #history-panel, #current-state-panel, #graph-panel, #cumulative-graph-panel, #tuning-controls, #story-mode-panel, #controls { padding: 10px; background-color: #e9e9e9; border: 1px solid #ccc; border-radius: 4px }
        #status p, #environment-status p, #population-stats p, #major-events p, #lifetime-stats p, #spotlight-panel p, #history-panel p, #current-state-panel p, #graph-panel p, #cumulative-graph-panel p, #tuning-controls p, #story-mode-panel p { margin: 3px 0; font-size: .9em }
        h1 { display: inline-block; /* Helps alignment with the button */ vertical-align: middle; /* Match button alignment */ margin-bottom: 5px; font-size: 1.6em }
        #running-story-label { font-size: 0.9em; color: #555; margin-top: 5px; font-style: italic; display: block; min-height: 1.2em; }
        h2 { color: #333; margin-top: 0; margin-bottom: 6px; font-size: 1em; border-bottom: 1px solid #ccc; padding-bottom: 2px }
        p.description { font-size: .9em; color: #555; margin-bottom: 10px }
        #major-log-container { max-height: 150px; overflow-y: auto; background-color: #ddd; color: #333; padding: 8px; border-radius: 4px; font-family: monospace; font-size: .8em; border: 1px solid #bbb; margin-top: 4px }
        #major-log-container .log-entry { margin-bottom: 1px; padding-bottom: 1px; word-wrap: break-word; border-bottom: 1px dotted #aaa }
        #major-log-container .log-entry:last-child { border-bottom: none }
        #log-container { flex-grow: 1; overflow-y: auto; background-color: #333; color: #f0f0f0; padding: 10px; border-radius: 4px; font-family: monospace; font-size: .8em; border: 1px solid #555; min-height: 100px }
        #log-container .log-entry { margin-bottom: 2px; border-bottom: 1px dotted #555; padding-bottom: 2px; word-wrap: break-word }
        #log-container .log-entry:last-child { border-bottom: none }
        #toggleLineageButton { margin-top: 5px; padding: 3px 8px; font-size: .8em; cursor: pointer; background-color: #6c757d; color: #fff; border: none; border-radius: 3px }
        #spotlight-output { max-height: 180px; overflow-y: auto; background-color: #f8f8f8; border: 1px dashed #aaa; padding: 5px; margin-top: 5px; font-family: monospace; font-size: .75em; white-space: pre-wrap; word-wrap: break-word; display: none; }
        #spotlight-output.lineage-visible { display: block }
        .lineage-turn { color: #6c757d; }
        .lineage-id { color: #007bff; font-weight: bold; }
        .lineage-genome { color: #555; }
        .lineage-status-alive { color: #28a745; }
        .lineage-status-dead { color: #dc3545; }
        .lineage-death-reason { color: #fd7e14; font-style: italic; }
        .lineage-error { color: #ff0000; font-weight: bold; }
        #historyVis { border: 1px solid #999; image-rendering: pixelated; image-rendering: crisp-edges; background-color: #333; margin-top: 5px; display: block }
        #historyLegend { font-size: .75em; line-height: 1.2; margin-top: 3px; color: #555 }
        #current-state-panel p { margin-bottom: 1px; display: flex; align-items: center }
        .color-swatch { display: inline-block; width: 14px; height: 14px; border: 1px solid #555; margin-right: 6px; vertical-align: middle; flex-shrink: 0 }
        .current-state-label { display: inline-block; width: 90px; font-weight: 400; color: #333; margin-right: 5px }
        .current-state-value { font-weight: 700; color: #000 }
        #graph-panel, #cumulative-graph-panel { }
        #coreGraphCanvas, #cumulativeGraphCanvas { width: 100%; height: 60px; background-color: #ffffff; border: 1px solid #bbb; display: block; margin-top: 5px; }
        .graph-legend { font-size: 0.8em; margin-top: 3px; color: #333; }
        .graph-legend span { display: inline-block; margin-right: 15px; }
        .graph-legend .pop-color { color: #3498db; }
        .graph-legend .fit-color { color: #e74c3c; }
        .cumulative-graph-legend .born-color { color: #2ecc71; }
        .cumulative-graph-legend .mutation-color { color: #9b59b6; }
        .cumulative-graph-legend .death-color { color: #7f8c8d; }
        #tuning-controls details { border: 1px solid #bbb; border-radius: 4px; padding: 5px; background: #e0e0e0; }
        #tuning-controls summary { cursor: pointer; font-weight: bold; color: #333; padding-bottom: 3px; }
        #tuning-controls .control-group { margin-bottom: 8px; padding-left: 5px; }
        #tuning-controls label { font-size: 0.9em; display: block; margin-bottom: 1px; color: #444;}
        #tuning-controls input[type="range"] { width: 70%; vertical-align: middle; height: 16px; margin: 0 5px 0 0; }
        #tuning-controls select, #tuning-controls input[type="checkbox"] { vertical-align: middle; margin-left: 5px;}
        #tuning-controls .value-display { font-size: 0.9em; font-weight: bold; vertical-align: middle; display: inline-block; min-width: 40px; text-align: right; margin-right: 5px;}
        #story-mode-panel details { border: 1px solid #bbb; border-radius: 4px; padding: 5px; background: #e0e0e0; }
        #story-mode-panel summary { cursor: pointer; font-weight: bold; color: #333; padding-bottom: 3px; font-size: 1em; border-bottom: 1px solid #ccc; margin-bottom: 6px; display: block; }
        /* Style for the +/- toggle icon */
        .toggle-icon { display: inline-block; width: 1.5em; text-align: center; font-weight: bold; margin-right: 4px; }
        #story-list { max-height: 250px; overflow-y: auto; border: 1px solid #bbb; padding: 5px; background-color: #f0f0f0; margin-top: 5px; }
        .story-preset-item { border-bottom: 1px dotted #ccc; padding: 8px 5px; }
        .story-preset-item:last-child { border-bottom: none; }
        .story-preset-item h3 { margin: 0 0 3px 0; font-size: 1.1em; color: #222; }
        .story-preset-item p { margin: 2px 0; font-size: 0.85em; }
        .story-hook { font-style: italic; color: #444; }
        .story-summary { color: #666; font-weight: bold; }
        .story-load-button { padding: 5px 10px; font-size: 0.85em; margin-top: 5px; background-color: #337ab7; width: auto; display: inline-block; }
        .story-load-button.loaded { background-color: #f0ad4e; color: #333; font-weight: bold; }
        .log-entry.Summary{color:#87ceeb}
        .log-entry.Birth{color:#90ee90}
        .log-entry.Death{color:#f08080}
        .log-entry.Environment{color:#ffab70;font-weight:700}
        .log-entry.Disturbance{color:#ff4500;font-weight:700}
        .log-entry.Mutation{color:#dda0dd}
        .log-entry.System{color:#b8b890}
        .log-entry.Observer{color:#cdaa70; font-style: italic;}
        .log-entry.Mythos{color: #6a0dad; font-style: italic; font-weight: 500; }
        .log-entry.Story{color: #d2691e; font-style: italic; font-weight: 500;}
        .log-entry.Warning{color:#ffa500}
        .log-entry.Error{color:#ff6347;font-weight:700}
        .log-entry.Debug{color:#777}
        .highlight{color:#ff4500;font-weight:700}
        #major-log-container .log-entry.Environment{color:#d95f02}
        #major-log-container .log-entry.Disturbance{color:#c00}
        #major-log-container .log-entry.System{color:#444}
        #major-log-container .log-entry.Observer{color:#a07d50; font-style: italic;}
        #major-log-container .log-entry.Mythos{color: #551a8b; font-style: italic; font-weight: bold;}
        #major-log-container .log-entry.Story{color: #a0522d; font-style: italic; font-weight: bold;}
        #mythos-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1000; overflow: hidden; }
        .mythos-floater { position: absolute; font-family: 'Courier New', Courier, monospace; font-size: 1.6em; font-weight: 500; color: rgba(75, 0, 130, 0.6); text-shadow: 0px 0px 3px rgba(255, 255, 255, 0.4); opacity: 0; transition: opacity 0.9s ease-in-out; white-space: normal; max-width: 45%; pointer-events: none; animation: mythosDrift 8s linear infinite alternate; padding: 6px 10px; background-color: rgba(230, 230, 250, 0.05); border-radius: 3px; will-change: opacity, transform; }
        @keyframes mythosDrift { from { transform: translate(0, 0); } to { transform: translate(4px, -7px); } }
        @media (max-width:800px){ body{padding:10px;font-size:13px} #mythographicBarCanvas { height: 35px; } #main-content{flex-direction:column;overflow:visible} #left-column{flex:1 1 auto;width:100%;order:1} #right-column{flex:1 1 auto;width:100%;min-height:300px;order:2;overflow-y:visible;padding-right:0} #major-log-container{max-height:100px} #log-container{max-height:40vh} #historyVis{width:100%;height:10px} .current-state-label{width:auto} #coreGraphCanvas,#cumulativeGraphCanvas{height:50px} h1{font-size:1.4em} .mythos-floater { font-size: 1.3em; max-width: 75%; } #story-list { max-height: 200px; } #left-column { flex: 0 0 auto; } }

        /* --- START: Updated About Button Style --- */
        /* Style for the 'About' button - Made Smaller */
        #aboutButton {
            display: inline-block;
            vertical-align: middle;
            margin-left: 15px; /* Keeps spacing from title */
            padding: 2px 6px;   /* REDUCED padding (was 4px 10px) */
            font-size: 0.8em;  /* REDUCED font size (was 0.9em) */
            color: #fff;
            background-color: #6c757d;
            border: none;
            border-radius: 3px; /* Slightly smaller radius to match */
            text-decoration: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #aboutButton:hover {
            background-color: #5a6268; /* Darker grey on hover */
        }
        /* --- END: Updated About Button Style --- */

    </style>
</head>
<body>

    <!-- Updated Title and About Button -->
    <h1 title="The main title of the simulation interface.">Terrarium Zero - Version 10.2</h1><a href="about.html" target="_blank" rel="noopener noreferrer" id="aboutButton" title="Learn more about Terrarium Zero (opens new tab)">About 🌱</a>
    <canvas id="mythographicBarCanvas" title="Visual representation of the simulation's state and history, including biome, celestial events, particles, and disturbances."></canvas>
    <div id="running-story-label" title="Indicates the type of simulation run active (Manual, Preset, or Modified Preset).">&nbsp;</div>
    <!-- Updated Description -->
    <p class="description" title="A brief overview of the simulation's theme.">A living mesocosm: emergent, fragile, and always starting over.</p>

    <!-- Main Content Structure -->
    <div id="main-content">
        <div id="left-column">
             <!-- Story Mode Panel with +/- Toggle -->
             <div id="story-mode-panel" title="Panel for selecting predefined simulation scenarios (Story Presets).">
                 <details open title="Expand/collapse story preset selection panel. Click the [-]/[+] icon or text.">
                     <summary><span class="toggle-icon">[-]</span>Story Mode Presets</summary>
                     <p style="font-size: 0.85em; color: #555;" title="Explanation of how to use Story Mode presets.">Select a story to load its parameters into the Manual Tuning Controls below. You can then modify them before starting.</p>
                     <div id="story-list" title="List of available story presets. Click 'Load Settings' to stage parameters."> Loading stories... </div>
                 </details>
             </div>
             <div id="controls" title="Primary simulation control buttons.">
                 <h2>Simulation Controls</h2>
                 <button id="startButton" title="Starts a new simulation run using the settings currently shown in 'Manual Tuning Controls'. Load a preset first to use story settings.">Start Simulation</button>
                 <button id="stopButton" disabled title="Stops the currently running simulation.">Stop Simulation</button>
                 <button id="spotlightButton" title="Identifies the living organism with the highest current fitness score and displays its lineage information below. Requires manual click to update.">Spotlight Fittest (Manual Refresh)</button>
                 <button id="saveReportButton" style="display: none;" title="Save a text report of the final simulation state and settings. Only appears when simulation is stopped.">Save End Report</button>
             </div>
             <div id="tuning-controls" title="Panel for adjusting simulation parameters before starting a run.">
                 <details open title="Expand/collapse controls for adjusting simulation parameters. Settings are used when 'Start Simulation' is clicked.">
                     <summary>Manual Tuning Controls</summary>
                     <div class="control-group" title="Adjusts the base amount of resources available in the environment and the rate at which they regenerate. Affects carrying capacity.">
                         <label for="resourceMultiplierSlider">Resource Multiplier:</label>
                         <span id="resourceMultiplierValue" class="value-display" title="Current resource multiplier setting (percentage of base values).">100%</span>
                         <input type="range" id="resourceMultiplierSlider" min="0" max="400" value="100" step="10" title="Slide to change the resource multiplier percentage (0% to 400%).">
                     </div>
                     <div class="control-group" title="Controls the base probability that an offspring will have a mutation compared to its parent.">
                         <label for="mutationRateSlider">Mutation Rate:</label>
                         <span id="mutationRateValue" class="value-display" title="Current mutation rate percentage.">10%</span>
                         <input type="range" id="mutationRateSlider" min="0" max="100" value="10" step="1" title="Adjust the mutation probability (0% to 100%).">
                     </div>
                     <div class="control-group" title="Controls how quickly the environment progresses through its defined sequence of zones. Higher values mean faster changes.">
                         <label for="successionSpeedSlider">Succession Speed:</label>
                         <span id="successionSpeedValue" class="value-display" title="Current succession speed multiplier (relative to base speed).">1.0x</span>
                         <input type="range" id="successionSpeedSlider" min="0.1" max="5" value="1" step="0.1" title="Adjust the speed multiplier for zone succession (0.1x to 5.0x).">
                     </div>
                     <div class="control-group" title="Controls the likelihood of random environmental disturbances occurring. Higher values mean more frequent disturbances.">
                         <label for="disturbanceRateSlider">Disturbance Rate:</label>
                         <span id="disturbanceRateValue" class="value-display" title="Current disturbance rate multiplier (relative to base probability).">1.0x</span>
                         <input type="range" id="disturbanceRateSlider" min="0.1" max="5" value="1" step="0.1" title="Adjust the frequency multiplier for disturbances (0.1x to 5.0x).">
                     </div>
                     <div class="control-group" title="Controls the magnitude of Phenotype-Environment Feedback (PEFF). Higher values mean stronger feedback, shifting ideal traits based on population average.">
                         <label for="peffIntensitySlider">PEFF Intensity:</label>
                         <span id="peffIntensityValue" class="value-display" title="Current intensity/magnitude of the PEFF effect.">0.02</span>
                         <input type="range" id="peffIntensitySlider" min="0" max="0.10" value="0.02" step="0.005" title="Adjust the strength of PEFF (0.000 to 0.100).">
                     </div>
                     <div class="control-group" title="Selects the fitness thresholds for survival and reproduction. Affects selection pressure.">
                         <label for="fitnessCurveSelect">Fitness Curve:</label>
                         <select id="fitnessCurveSelect" title="Choose selection pressure: Neutral (weak), Balanced (moderate), Harsh (strong).">
                             <option value="neutral">Neutral Drift</option>
                             <option value="balanced" selected>Balanced Selection</option>
                             <option value="harsh">Harsh Selection</option>
                         </select>
                     </div>
                     <div class="control-group" title="Selects the level of detail and frequency for the Observer reports in the Major Events log.">
                         <label for="observerModeSelect">Observer Mode:</label>
                         <select id="observerModeSelect" title="Choose Observer style: Minimal (less frequent, basic), Cold (standard frequency, factual), Reflective (standard frequency, more descriptive).">
                             <option value="minimal">Minimal</option>
                             <option value="cold">Cold</option>
                             <option value="reflective" selected>Reflective</option>
                         </select>
                     </div>
                     <div class="control-group" title="Enable/disable calculation and display of Genome Entropy (a measure of genetic diversity within the population).">
                         <label for="genomeEntropyToggle">Genome Entropy Tracker:</label>
                         <input type="checkbox" id="genomeEntropyToggle" title="Check to enable Genome Entropy calculation and display.">
                     </div>
                 </details>
             </div>
             <div id="status" title="Core status indicators for the simulation.">
                 <h2>Simulation Status</h2>
                 <p title="Current operational state of the simulation.">State: <span id="simState">Stopped</span></p>
                 <p title="The number of simulation steps (turns) that have elapsed.">Turn: <span id="turnCounter">0</span></p>
                 <p title="Indicates the type and turn number of the last major environmental disturbance event (Cull or Reset).">Last Disturbance: <span id="lastDisturbance">None</span></p>
             </div>
             <div id="population-stats" title="Statistics about the current population of organisms.">
                 <h2>Population Stats</h2>
                 <p title="Current number of living organisms vs maximum allowed population size.">Population: <span id="populationCount">0</span> / <span id="populationCap">N/A</span></p>
                 <p title="Average fitness score (0-1, higher is better adapted) across all living organisms.">Avg Fitness: <span id="avgFitness">N/A</span></p>
                 <p title="Average length (number of characters) of genome strings across the population.">Avg Genome Len: <span id="avgGenomeLength">N/A</span></p>
                 <p title="Population average scores (0-1) for Efficiency, Mobility, and Resilience traits.">Avg Phenotype (E/M/R): <span id="avgPhenotype">N/A</span></p>
                 <p title="Average lifespan multiplier across the population (relative to base lifespan).">Avg Lifespan Mult: <span id="avgLifespanMultiplier">N/A</span></p>
                 <p title="Shannon entropy of unique genomes (a measure of genetic diversity). Only calculated if enabled in Tuning Controls.">Genome Entropy: <span id="genomeEntropy">Off</span></p>
             </div>
             <div id="environment-status" title="Information about the current environmental conditions.">
                 <h2>Environment Status</h2>
                 <p title="Name of the current environmental zone or stage.">Current Zone: <span id="environmentZone">N/A</span></p>
                 <p title="Number of turns spent in the current zone vs the number of turns needed for succession to the next zone (affected by Succession Speed setting).">Time in Zone: <span id="timeInZone">0</span> / <span id="zoneDuration">N/A</span> turns</p>
                 <p title="The 'ideal' trait values (Efficiency/Mobility/Resilience, 0-1) currently favored by the zone. These can shift over time due to PEFF.">Ideal Traits (E/M/R): <span id="idealTraits">N/A</span></p>
                 <p title="Current available resources vs the maximum resource capacity for this zone (affected by Resource Multiplier setting).">Resources: <span id="environmentResources">N/A</span></p>
             </div>
             <div id="lifetime-stats" title="Cumulative statistics tracked since the simulation started.">
                 <h2>Lifetime Stats</h2>
                 <p title="Total number of organisms ever created (born or initial population).">Total Born: <span id="totalBorn">0</span></p>
                 <p title="Total number of mutation events that occurred during reproduction.">Total Mutations: <span id="totalMutations">0</span></p>
                 <p title="The longest lifespan (in turns) recorded for any organism during this run.">Max Age Recorded: <span id="maxAge">0</span></p>
                 <p title="Total number of deaths from any cause.">Total Deaths (All): <span id="totalDeaths">0</span></p>
                 <p style="padding-left: 10px;" title="Total number of deaths from reaching the natural lifespan limit.">Old Age: <span id="totalOldAgeDeaths">0</span></p>
                 <p style="padding-left: 10px;" title="Total number of deaths from lack of sufficient resources.">Starvation: <span id="totalStarvationDeaths">0</span></p>
                 <p style="padding-left: 10px;" title="Total number of deaths from falling below the minimum fitness survival threshold.">Low Fitness: <span id="totalLowFitnessDeaths">0</span></p>
                 <p style="padding-left: 10px;" title="Total number of deaths due to exceeding the population capacity (least fit removed).">Fitness Culls (Cap): <span id="totalCapCulls">0</span></p>
                 <p style="padding-left: 10px;" title="Total number of deaths caused by random 'Cull' type disturbances.">Disturbance Culls: <span id="totalDisturbanceCulls">0</span></p>
             </div>
             <div id="spotlight-panel" title="Tool to inspect the fittest currently living organism.">
                 <h2>Organism Spotlight</h2>
                 <p title="ID and key stats of the currently fittest living organism (requires manual refresh using the 'Spotlight Fittest' button).">Target: <span id="spotlightTarget">None</span></p>
                 <button id="toggleLineageButton" title="Show or hide the ancestral lineage trace of the spotlighted organism.">[Show Lineage]</button>
                 <div id="spotlight-output" title="Lineage trace of the spotlighted organism, showing ancestors back to the simulation start.">Lineage will appear here...</div>
             </div>
        </div>
        <div id="right-column">
             <div id="history-panel" title="Compact visualization of key metrics over the recent history (approx. last 400 turns).">
                 <h2 title="Compact visualization of key metrics over recent history.">Recent History (~400 Turns)</h2>
                 <canvas id="historyVis" width="800" height="10" title="Pixel-based timeline of key metrics (last ~400 turns). Each column is a turn (wraps). See legend below for row meanings."></canvas>
                 <div id="historyLegend" title="Explains the data shown in each row of the history visualization canvas (top to bottom)."> Top(0-1px) to Bottom(8-9px): Zone | Pop Size | Avg Fitness | Avg Lifespan | Dominant Focus </div>
             </div>
             <div id="current-state-panel" title="Color-coded legend showing the current values corresponding to the History visualization rows.">
                 <h2 title="Color-coded legend showing current values for History visualization.">Current State Legend</h2>
                 <p title="Current environmental zone and its corresponding color in the history viz."><span class="color-swatch" id="currentStateZoneColor"></span><span class="current-state-label">Zone:</span><span class="current-state-value" id="currentStateZoneValue">N/A</span></p>
                 <p title="Current population size and its corresponding color intensity in the history viz."><span class="color-swatch" id="currentStatePopColor"></span><span class="current-state-label">Population:</span><span class="current-state-value" id="currentStatePopValue">N/A</span></p>
                 <p title="Current average fitness and its corresponding color in the history viz."><span class="color-swatch" id="currentStateFitnessColor"></span><span class="current-state-label">Avg Fitness:</span><span class="current-state-value" id="currentStateFitnessValue">N/A</span></p>
                 <p title="Current average lifespan multiplier and its corresponding color in the history viz."><span class="color-swatch" id="currentStateLifespanColor"></span><span class="current-state-label">Avg Lifespan:</span><span class="current-state-value" id="currentStateLifespanValue">N/A</span></p>
                 <p title="Current dominant adaptive focus (trait best matching the environment's ideal) and its corresponding color in the history viz."><span class="color-swatch" id="currentStateFocusColor"></span><span class="current-state-label">Dominant Focus:</span><span class="current-state-value" id="currentStateFocusValue">N/A</span></p>
             </div>
             <div id="graph-panel" title="Graph showing smoothed trends of core population dynamics over recent history.">
                 <h2 title="Smoothed trends of population and fitness over recent history.">Core Dynamics (Smoothed, ~400 Turns)</h2>
                 <canvas id="coreGraphCanvas" width="800" height="60" title="Graph: Smoothed Population size (blue line) and Average Fitness (red line) over the last ~400 turns. Y-axis: Pop 0-MaxCap, Fitness 0-1."></canvas>
                 <div class="graph-legend" title="Key for the Core Dynamics graph lines and axes."> <span class="pop-color">■ Population</span> <span class="fit-color">■ Avg Fitness</span> <span>(Pop 0-150, Fit 0-1)</span> </div>
             </div>
             <div id="cumulative-graph-panel" title="Graph showing cumulative totals of key events over recent history.">
                 <h2 title="Cumulative totals of key events over recent history.">Cumulative History (~400 Turns)</h2>
                 <canvas id="cumulativeGraphCanvas" width="800" height="60" title="Graph: Cumulative Total Organisms Born (green), Total Mutations (purple), and Total Deaths (gray) over the last ~400 turns. Y-axis scales automatically."></canvas>
                 <div class="graph-legend cumulative-graph-legend" title="Key for the Cumulative History graph lines. Y-axis scales automatically based on max value shown."> <span class="born-color">■ Total Born</span> <span class="mutation-color">■ Total Mutations</span> <span class="death-color">■ Total Deaths</span> <span id="cumulativeYMaxLabel">(Y-Max: Auto)</span> </div>
             </div>
             <div id="major-events" title="Log displaying significant simulation events: environmental changes, disturbances, Observer reports, Mythos leaks, Story flavor text, and system messages.">
                 <h2 title="Log displaying significant events: env changes, disturbances, observer/mythos/story reports, system messages.">Major Events</h2>
                 <div id="major-log-container" title="Scrollable log area for major simulation events. Most recent at the top.">
                     <div id="majorLogEntries">Major events log will appear here...</div>
                 </div>
             </div>
             <div title="Detailed, turn-by-turn log of all simulation events.">
                 <h2 title="Detailed, turn-by-turn log of all simulation events.">Simulation Log (Detailed)</h2>
                 <div id="log-container" title="Scrollable log area for detailed simulation output. Most recent at the top.">
                     <div id="logEntries">Detailed simulation log will appear here...</div>
                 </div>
             </div>
        </div>
    </div>

    <div id="mythos-overlay" title="Overlay area for floating Mythos Engine text fragments."></div>

    <script type="module">
        // --- STORY PRESET DATA (Identical to 9.7 / 10.2html) ---
        const storyPresets = [ { id: "fire_sermon", title: "The Fire Sermon", hook: "In a world consumed by constant change, only volatility brings survival. Life flickers, brief and bright, against the endless blaze.", summary: "High mutation, fast succession, high disturbance, standard resources.", parameters: { mutationRate: 0.60, successionSpeedMultiplier: 3.0, disturbanceRateMultiplier: 3.5, peffIntensity: 0.05, resourceMultiplier: 1.0, fitnessCurve: 'harsh', genomeEntropyEnabled: true }, flavorText: { turn300: ["The ashes stir anew.", "Another cycle burns away.", "Change is the only constant."], extinction: ["The final spark gutters.", "Silence returns to the cinder plains.", "They forgot how to change."], peakEntropy: ["A cacophony of forms.", "Too many voices, none heard.", "The pattern dissolves."] } }, { id: "ash_architects", title: "Ash of the Architects", hook: "Great designs, optimized and perfected, stood for ages. But the world changed, and their legacy systems proved tragically brittle.", summary: "Low mutation, slow succession, periodic high disturbance, balanced fitness.", parameters: { mutationRate: 0.02, successionSpeedMultiplier: 0.5, disturbanceRateMultiplier: 1.5, peffIntensity: 0.01, resourceMultiplier: 1.2, fitnessCurve: 'balanced', genomeEntropyEnabled: false }, flavorText: { turn500: ["The old ways endure... for now.", "Cracks appear in the foundation.", "Whispers of obsolescence."], disturbance: ["The storm reveals the flaws.", "What was strong is now broken.", "Sudden shifts shatter the mold."], extinction: ["The archives crumble to dust.", "Their perfection was their end.", "Progress requires adaptation."] } }, { id: "hollow_bloom", title: "The Hollow Bloom", hook: "In a land of effortless plenty, a single, dominant form thrived, unchallenged. But abundance without pressure breeds stagnation, a beautiful decay.", summary: "Very low mutation, low disturbance, high resources, neutral drift focus.", parameters: { mutationRate: 0.01, successionSpeedMultiplier: 1.0, disturbanceRateMultiplier: 0.2, peffIntensity: 0.005, resourceMultiplier: 3.0, fitnessCurve: 'neutral', genomeEntropyEnabled: true }, flavorText: { turn500: ["The monoculture reigns supreme.", "A perfect, unchanging garden.", "Is this peace, or paralysis?"], lowEntropy: ["The song becomes a drone.", "Variation fades.", "The bloom begins to wither."], extinction: ["The last petal falls.", "Emptiness follows excess.", "Comfort is a slow killer."] } }, { id: "still_waters", title: "Still Waters", hook: "An almost silent world. Change is glacial, life sparse. Yet, beneath the calm surface, potential gathers, awaiting a rare spark.", summary: "Ultra-low activity (mutation, succession, disturbance), high resources.", parameters: { mutationRate: 0.005, successionSpeedMultiplier: 0.2, disturbanceRateMultiplier: 0.1, peffIntensity: 0.001, resourceMultiplier: 2.5, fitnessCurve: 'neutral', genomeEntropyEnabled: false }, flavorText: { turn1000: ["Centuries pass like moments.", "The deep quiet holds.", "Waiting..."], mutation: ["A ripple disturbs the calm.", "A new thought, slow to form.", "Potential stirs."], extinction: ["The stillness becomes final.", "The potential remains unrealized.", "Even silence ends."] } }, { id: "chorus_forgotten", title: "Chorus of the Forgotten", hook: "Life adapts, survives, but the code drifts. Traits blur, memories fade. Entropy's gentle hum underscores a world losing its definition.", summary: "Moderate settings overall, but emphasizing genetic drift and entropy.", parameters: { mutationRate: 0.15, successionSpeedMultiplier: 1.0, disturbanceRateMultiplier: 1.0, peffIntensity: 0.02, resourceMultiplier: 1.5, fitnessCurve: 'balanced', genomeEntropyEnabled: true }, flavorText: { turn500: ["Forms shift like smoke.", "Is this evolution, or erosion?", "The past becomes indistinct."], highEntropy: ["A chorus of whispers, meaning lost.", "They forgot how to change... or how to stay the same.", "Identity frays."], extinction: ["The song fades into noise.", "Memory fails, survival follows.", "Entropy claims the last verse."] } } ];

        // --- BASE CONFIGURATION (Defaults, identical to 9.8 / 10.2html) ---
        const config = { TICK_INTERVAL_MS: 80, INITIAL_POPULATION: 15, INITIAL_GENOME: "A3B34", MIN_GENOME_LENGTH: 5, MAX_GENOME_LENGTH: 35, BASE_LIFESPAN: 120, DEFAULT_DEATH_THRESHOLD: 0.15, DEFAULT_REPRODUCTION_THRESHOLD: 0.60, MIN_REPRODUCTION_AGE: 10, DEFAULT_MUTATION_RATE: 0.10, MUTATION_TYPE_PROBS: { point: 0.5, insertion: 0.2, deletion: 0.2, swap: 0.1 }, GENOME_CHARS: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", FITNESS_WEIGHTS: { efficiency: 0.4, mobility: 0.3, resilience: 0.3 }, SUCCESSION_TIMER_BASE: 100, BASE_CONSUMPTION_RATE: 0.3, REPRODUCTION_RESOURCE_COST: 40.0, ZONE_DEFINITIONS_BASE: { "Barren": { ideal_efficiency: 0.1, ideal_mobility: 0.1, ideal_resilience: 0.8, initial_resources: 1000, regen_rate: 1.5 }, "PioneerScrub": { ideal_efficiency: 0.4, ideal_mobility: 0.2, ideal_resilience: 0.6, initial_resources: 1500, regen_rate: 2.0 }, "Grassland": { ideal_efficiency: 0.7, ideal_mobility: 0.6, ideal_resilience: 0.3, initial_resources: 2500, regen_rate: 4.0 }, "YoungForest": { ideal_efficiency: 0.6, ideal_mobility: 0.3, ideal_resilience: 0.7, initial_resources: 2000, regen_rate: 3.0 }, "MatureForest": { ideal_efficiency: 0.8, ideal_mobility: 0.2, ideal_resilience: 0.8, initial_resources: 3000, regen_rate: 2.5 }, "Wetland": { ideal_efficiency: 0.5, ideal_mobility: 0.4, ideal_resilience: 0.5, initial_resources: 1800, regen_rate: 3.0 }, }, ZONE_SEQUENCE: ["Barren", "PioneerScrub", "Grassland", "YoungForest", "MatureForest", "Wetland"], DEFAULT_DISTURBANCE_PROBABILITY: 0.008, DISTURBANCE_TYPES: ['cull', 'reset'], DISTURBANCE_CULL_RANGE: [0.3, 0.7], MAX_LOG_ENTRIES_DISPLAY: 150, POPULATION_CAP: 150, MAX_MAJOR_LOG_ENTRIES_DISPLAY: 50, GRAPH_WINDOW_SIZE: 400, GRAPH_SMOOTHING_WINDOW: 20, SPOTLIGHT_AUTO_UPDATE_INTERVAL: 25, DEFAULT_OBSERVER_INTERVAL: 50, TSE_ENABLED: true, TSE_MAX_MODIFIER: 0.1, TSE_THRESHOLDS: { HIGH_MOBILITY: 0.7, HIGH_EFFICIENCY: 0.7, LOW_EFFICIENCY: 0.3, HIGH_RESILIENCE: 0.7, LOW_RESILIENCE: 0.3, LOW_MOBILITY: 0.3, SHORT_GENOME: 7, LONG_GENOME: 25, BLOATED_RESILIENCE_REQ: 0.6 }, TSE_MODIFIERS: { BURST_ECOTYPE: -0.1, TANK_FORM: +0.05, GENERALIST_DRIFT: 0, ROOTBOUND: 0, STREAMLINED: +0.05, BLOATED: -0.05 }, TSE_LOG_THRESHOLD: 0.01, PEFF_ENABLED: true, PEFF_INTERVAL: 50, DEFAULT_PEFF_SHIFT_MAGNITUDE: 0.02, PEFF_MODE: "follow", PEFF_MAX_SHIFT: 0.3, MYTHOS_ENABLED: true, MYTHOS_INTERVAL: 100, MYTHOS_BURST_PROBABILITY: 0.01, MYTHOS_FLOAT_DURATION_MS: 7000, MYTHOS_FADE_DURATION_MS: 900, STORY_FLAVOR_TRIGGERS: { peakEntropy: 4.8, lowEntropy: 1.2, highEntropy: 4.5 },
             MYTHO_BAR_HISTORY_LENGTH: 31, MYTHO_BAR_TRAIT_LOCK_TURNS: 100, MYTHO_BAR_ENTROPY_DELTA_THRESHOLD: 0.5, MYTHO_BAR_MUTATION_RATE_HIGH: 0.08, MYTHO_PARTICLE_LIFETIME: 20, MYTHO_MAX_PARTICLES_PER_TICK: 10, MYTHO_DISTURBANCE_RATE_HIGH: 1.0, MYTHO_LIGHTNING_FLASH_FRAMES: 2, MYTHO_FITNESS_HIGH: 0.85, MYTHO_FITNESS_LOW: 0.50, };

        // --- UTILITY FUNCTIONS (Identical to 9.8 / 10.2html) ---
        const Utils = { randomChar: () => config.GENOME_CHARS[Math.floor(Math.random() * config.GENOME_CHARS.length)], randomInRange: (min, max) => Math.random() * (max - min) + min, interpretGenome: (genome) => { const p = { metabolism: 'Unknown', efficiency: 0.0, mobility: 0.0, resilience: 0.0, lifespanMultiplier: 1.0 }; if (!genome || typeof genome !== 'string' || genome.length === 0) return p; const mC = genome[0].toUpperCase(); if (mC === 'A') p.metabolism = 'Autotroph'; else if (mC === 'B') p.metabolism = 'Heterotroph'; if (genome.length > 1) { const eC = genome[1]; if (!isNaN(parseInt(eC))) p.efficiency = parseInt(eC) / 9.0; } if (genome.length > 2) { const moC = genome[2].toUpperCase(); const cC = moC.charCodeAt(0); if (cC >= 65 && cC <= 90) p.mobility = (cC - 65) / 25.0; } if (genome.length > 3) { const rC = genome[3]; if (!isNaN(parseInt(rC))) p.resilience = parseInt(rC) / 9.0; } if (genome.length > 4) { const lC = genome[4]; if (!isNaN(parseInt(lC))) { const digitValue = parseInt(lC); p.lifespanMultiplier = 0.6 + (digitValue * 0.1); } } p.efficiency = Math.max(0, Math.min(1, p.efficiency)); p.mobility = Math.max(0, Math.min(1, p.mobility)); p.resilience = Math.max(0, Math.min(1, p.resilience)); p.lifespanMultiplier = Math.max(0.1, Math.min(2.0, p.lifespanMultiplier)); return p; }, getRandomElement: (arr) => { if (!arr || arr.length === 0) return ""; return arr[Math.floor(Math.random() * arr.length)]; }, calculateGenomeEntropy: (organisms) => { if (!organisms || organisms.length === 0) return 0; const genomeCounts = {}; let totalGenomes = 0; organisms.forEach(org => { if (org && org.alive && typeof org.genome === 'string') { const genome = org.genome; genomeCounts[genome] = (genomeCounts[genome] || 0) + 1; totalGenomes++; } }); if (totalGenomes === 0) return 0; let entropy = 0; for (const genome in genomeCounts) { if (Object.prototype.hasOwnProperty.call(genomeCounts, genome)) { const count = genomeCounts[genome]; const proportion = count / totalGenomes; if (proportion > 0) { entropy -= proportion * Math.log2(proportion); } } } return entropy; } };

        // --- LOGGER MODULE (Identical to 9.8 / 10.2html) ---
        class Logger { constructor(uiManager) { this.uiManager = uiManager; this.logHistory = []; this.majorLogHistory = []; this.MAJOR_EVENT_TYPES = ['Environment', 'Disturbance', 'Observer', 'Mythos', 'Story', 'Error']; this.SYSTEM_MAJOR_TRIGGERS = ['extinction', 'stopped', 'started', 'synergy update:', 'Story Started:', 'Modified Story Started:']; this.TSE_MAJOR_THRESHOLD = config.TSE_LOG_THRESHOLD * 5; this.currentTurnForLogger = 0; } setTurn(turn) { this.currentTurnForLogger = turn; } log(turn, type, message, details = {}) { this.setTurn(turn); let safeDetails = {}; for (const key in details) { if (Object.prototype.hasOwnProperty.call(details, key)) { const value = details[key]; if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) { safeDetails[key] = value; } else { safeDetails[key] = String(value); } } } const entry = { turn, type, message, timestamp: Date.now(), ...safeDetails }; this.logHistory.push(entry); if (this.uiManager) { this.uiManager.addDetailedLogEntry(entry); } let isMajor = this.MAJOR_EVENT_TYPES.includes(type); if (!isMajor && type === 'System') { const lowerMsg = message.toLowerCase(); if (this.SYSTEM_MAJOR_TRIGGERS.some(trigger => lowerMsg.includes(trigger))) { if (lowerMsg.includes('synergy update:')) { if (Math.abs(details?.synergyMod ?? 0) >= this.TSE_MAJOR_THRESHOLD) { isMajor = true; } } else { isMajor = true; } } } if (isMajor) { const majorEntry = { turn: entry.turn, type: entry.type, message: entry.message }; this.majorLogHistory.push(majorEntry); if (this.uiManager) { this.uiManager.addMajorLogEntry(majorEntry); } } } clearLogs() { this.logHistory = []; this.majorLogHistory = []; if (this.uiManager) { this.uiManager.clearHtmlLogs(); } } getLogs() { return { detailed: [...this.logHistory], major: [...this.majorLogHistory] }; } }

        // --- UI MANAGER MODULE (Includes changes from 9.8 / 10.2html for Mythobar Scanlines) ---
        class UIManager { constructor() { this.dom = {}; this.historyVisContext = null; this.coreGraphContext = null; this.cumulativeGraphContext = null; this.mythographicBarContext = null; this.clouds = []; this.stars = []; this.particles = []; this.lightningFlashFrames = 0; this.isExtinct = false; this.currentAvgFitness = 0; this.currentEntropyDelta30Tick = 0; this.getDomElements(); this.initializeCanvases(); this.updateAllSliderDisplays(); this.populateStoryPresets(); }
            getDomElements() { const ids = [ 'startButton', 'stopButton', 'spotlightButton', 'toggleLineageButton', 'saveReportButton', 'simState', 'turnCounter', 'lastDisturbance', 'populationCount', 'populationCap', 'avgFitness', 'avgGenomeLength', 'avgPhenotype', 'avgLifespanMultiplier', 'genomeEntropy', 'environmentZone', 'timeInZone', 'zoneDuration', 'idealTraits', 'environmentResources', 'logEntries', 'majorLogEntries', 'totalBorn', 'maxAge', 'totalMutations', 'totalDeaths', 'totalOldAgeDeaths', 'totalStarvationDeaths', 'totalLowFitnessDeaths', 'totalCapCulls', 'totalDisturbanceCulls', 'spotlightTarget', 'spotlight-output', 'historyVis', 'currentStateZoneColor', 'currentStateZoneValue', 'currentStatePopColor', 'currentStatePopValue', 'currentStateFitnessColor', 'currentStateFitnessValue', 'currentStateLifespanColor', 'currentStateLifespanValue', 'currentStateFocusColor', 'currentStateFocusValue', 'resourceMultiplierSlider', 'resourceMultiplierValue', 'coreGraphCanvas', 'cumulativeGraphCanvas', 'cumulativeYMaxLabel', 'tuning-controls', 'mutationRateSlider', 'mutationRateValue', 'successionSpeedSlider', 'successionSpeedValue', 'disturbanceRateSlider', 'disturbanceRateValue', 'peffIntensitySlider', 'peffIntensityValue', 'fitnessCurveSelect', 'observerModeSelect', 'genomeEntropyToggle', 'mythos-overlay', 'story-mode-panel', 'story-list', 'running-story-label', 'resourceMultiplierSlider', 'mutationRateSlider', 'successionSpeedSlider', 'disturbanceRateSlider', 'peffIntensitySlider', 'fitnessCurveSelect', 'observerModeSelect', 'genomeEntropyToggle', 'mythographicBarCanvas' ]; let allFound = true; ids.forEach(id => { if (!this.dom[id]) { this.dom[id] = document.getElementById(id); if (!this.dom[id]) { console.warn(`UIManager: DOM ID ${id} not found`); allFound = false; } } }); return allFound; }
            initializeCanvases() { if (this.dom.historyVis) { this.historyVisContext = this.dom.historyVis.getContext('2d'); if (this.historyVisContext) { this.historyVisContext.fillStyle = '#333'; this.historyVisContext.fillRect(0, 0, this.dom.historyVis.width, this.dom.historyVis.height); } } if (this.dom.coreGraphCanvas) { this.coreGraphContext = this.dom.coreGraphCanvas.getContext('2d'); if (this.coreGraphContext) { this.coreGraphContext.fillStyle = '#FFF'; this.coreGraphContext.fillRect(0, 0, this.dom.coreGraphCanvas.width, this.dom.coreGraphCanvas.height); } } if (this.dom.cumulativeGraphCanvas) { this.cumulativeGraphContext = this.dom.cumulativeGraphCanvas.getContext('2d'); if (this.cumulativeGraphContext) { this.cumulativeGraphContext.fillStyle = '#FFF'; this.cumulativeGraphContext.fillRect(0, 0, this.dom.cumulativeGraphCanvas.width, this.dom.cumulativeGraphCanvas.height); } } if (this.dom.mythographicBarCanvas) { this.mythographicBarContext = this.dom.mythographicBarCanvas.getContext('2d'); if (!this.mythographicBarContext) { console.error("Failed to get 2D context for Mythographic Bar"); } else { this.mythographicBarContext.fillStyle = '#DDD'; this.mythographicBarContext.fillRect(0, 0, this.dom.mythographicBarCanvas.width, this.dom.mythographicBarCanvas.height); this.mythographicBarContext.fillStyle = '#AAA'; this.mythographicBarContext.font = '12px sans-serif'; this.mythographicBarContext.textAlign = 'center'; this.mythographicBarContext.fillText("Waiting for simulation...", this.dom.mythographicBarCanvas.width / 2, this.dom.mythographicBarCanvas.height / 2 + 4); } } }
            addDetailedLogEntry(entry) { if (!this.dom.logEntries) return; const logContainerDiv = document.getElementById('log-container'); const shouldScroll = logContainerDiv && (logContainerDiv.scrollHeight - logContainerDiv.scrollTop <= logContainerDiv.clientHeight + 50); const l = document.createElement('div'); l.classList.add('log-entry', entry.type); l.textContent = `[${entry.turn}] ${entry.type}: ${entry.message}`; if (entry.type === 'Disturbance' || entry.type === 'Mythos' || entry.type === 'Story') l.classList.add('highlight'); this.dom.logEntries.insertBefore(l, this.dom.logEntries.firstChild); while (this.dom.logEntries.children.length > config.MAX_LOG_ENTRIES_DISPLAY) { this.dom.logEntries.removeChild(this.dom.logEntries.lastChild); } if (shouldScroll) { logContainerDiv.scrollTop = 0; } }
            addMajorLogEntry(entry) { if (!this.dom.majorLogEntries) return; const logContainerDiv = document.getElementById('major-log-container'); const shouldScroll = logContainerDiv && (logContainerDiv.scrollHeight - logContainerDiv.scrollTop <= logContainerDiv.clientHeight + 50); const logLine = document.createElement('div'); logLine.classList.add('log-entry', entry.type); logLine.textContent = `[${entry.turn}] ${entry.type}: ${entry.message}`; if (entry.type === 'Disturbance' || entry.type === 'Mythos' || entry.type === 'Story') logLine.classList.add('highlight'); this.dom.majorLogEntries.insertBefore(logLine, this.dom.majorLogEntries.firstChild); while (this.dom.majorLogEntries.children.length > config.MAX_MAJOR_LOG_ENTRIES_DISPLAY) { this.dom.majorLogEntries.removeChild(this.dom.majorLogEntries.lastChild); } if (shouldScroll) { logContainerDiv.scrollTop = 0; } }
            updateMajorLogDisplay(majorLogHistory) { if (!this.dom.majorLogEntries) return; const entriesToShow = majorLogHistory.slice(-config.MAX_MAJOR_LOG_ENTRIES_DISPLAY); this.dom.majorLogEntries.innerHTML = ''; entriesToShow.reverse().forEach(entry => { const logLine = document.createElement('div'); logLine.classList.add('log-entry', entry.type); logLine.textContent = `[${entry.turn}] ${entry.type}: ${entry.message}`; if (entry.type === 'Disturbance' || entry.type === 'Mythos' || entry.type === 'Story') logLine.classList.add('highlight'); this.dom.majorLogEntries.appendChild(logLine); }); }
            clearHtmlLogs() { if (this.dom.logEntries) this.dom.logEntries.innerHTML = 'Log cleared.'; if (this.dom.majorLogEntries) this.dom.majorLogEntries.innerHTML = 'Major log cleared.'; }
            update(state, environment, dynamicSettings, tickEvents) { if (!state || !environment || !dynamicSettings) { return; } if (tickEvents) { this.isExtinct = tickEvents.isExtinct || false; if (tickEvents.disturbanceType === 'cull') { this.lightningFlashFrames = config.MYTHO_LIGHTNING_FLASH_FRAMES; } this.addParticles(tickEvents.birthCount, 'birth'); this.addParticles(tickEvents.deathCount, 'death'); this.addParticles(tickEvents.mutationCount, 'mutation'); this.currentAvgFitness = tickEvents.avgFitness; this.currentEntropyDelta30Tick = tickEvents.entropyDelta30Tick; } else { this.currentAvgFitness = 0; this.currentEntropyDelta30Tick = 0; } const envParams = environment.getParams(); this.setText(this.dom.simState, state.isRunning ? 'Running' : 'Stopped'); this.setText(this.dom.turnCounter, state.turn); this.setText(this.dom.lastDisturbance, state.lastDisturbance.type === "None" ? "None" : `${state.lastDisturbance.type} T${state.lastDisturbance.turn}`); const popCount = state.organisms.length; const popCap = config.POPULATION_CAP; this.setText(this.dom.populationCount, popCount); this.setText(this.dom.populationCap, popCap); if (dynamicSettings.genomeEntropyEnabled) { this.setText(this.dom.genomeEntropy, state.genomeEntropy.toFixed(3)); } else { this.setText(this.dom.genomeEntropy, 'Off'); } if (popCount > 0) { const avgFitness = state.averagePhenotype.calculatedTurn === state.turn ? state.averagePhenotype.F : 'N/A'; const avgGenomeLen = state.organisms.reduce((sum, org) => sum + (org?.genome?.length || 0), 0) / popCount; const avgPheno = state.averagePhenotype; const phenoStale = avgPheno.calculatedTurn !== state.turn && avgPheno.calculatedTurn !== -1; const phenoText = phenoStale ? '(Stale)' : ''; this.setText(this.dom.avgFitness, typeof avgFitness === 'number' ? avgFitness.toFixed(3) : avgFitness); this.setText(this.dom.avgGenomeLength, avgGenomeLen.toFixed(2)); this.setText(this.dom.avgPhenotype, avgPheno.calculatedTurn !== -1 ? `E${avgPheno.E.toFixed(2)} M${avgPheno.M.toFixed(2)} R${avgPheno.R.toFixed(2)}${phenoText}` : '...'); this.setText(this.dom.avgLifespanMultiplier, avgPheno.calculatedTurn !== -1 ? `${avgPheno.L.toFixed(2)}x${phenoText}` : '...'); } else { this.setText(this.dom.avgFitness, 'N/A'); this.setText(this.dom.avgGenomeLength, 'N/A'); this.setText(this.dom.avgPhenotype, 'N/A'); this.setText(this.dom.avgLifespanMultiplier, 'N/A'); } this.setText(this.dom.environmentZone, environment.getZoneName()); const effectiveDuration = config.SUCCESSION_TIMER_BASE / dynamicSettings.successionSpeedMultiplier; this.setText(this.dom.timeInZone, environment.getTimeInStage()); this.setText(this.dom.zoneDuration, effectiveDuration.toFixed(0)); this.setText(this.dom.idealTraits, `E${envParams.ideal_efficiency.toFixed(2)} M${envParams.ideal_mobility.toFixed(2)} R${envParams.ideal_resilience.toFixed(2)}`); const currentRes = environment.getCurrentResources(); const effectiveInitialRes = environment.getEffectiveInitialResources(); this.setText(this.dom.environmentResources, `${currentRes.toFixed(1)}/${effectiveInitialRes.toFixed(1)}`); this.setText(this.dom.totalBorn, state.nextOrganismId); this.setText(this.dom.totalMutations, state.totalMutations); this.setText(this.dom.maxAge, `${state.maxAgeRecorded} t`); this.setText(this.dom.totalDeaths, state.totalDeaths); this.setText(this.dom.totalOldAgeDeaths, state.totalOldAgeDeaths); this.setText(this.dom.totalStarvationDeaths, state.totalStarvationDeaths); this.setText(this.dom.totalLowFitnessDeaths, state.totalLowFitnessDeaths); this.setText(this.dom.totalCapCulls, state.totalCapCulls); this.setText(this.dom.totalDisturbanceCulls, state.totalDisturbanceCulls); this.setDisabled(this.dom.startButton, state.isRunning); document.querySelectorAll('.story-load-button').forEach(button => this.setDisabled(button, state.isRunning)); this.setDisabled(this.dom.stopButton, !state.isRunning); let runningLabel = '&nbsp;'; if (state.activeStoryId) { if (state.activeStoryId.startsWith('modified_')) { const baseId = state.activeStoryId.substring(9); const story = storyPresets.find(s => s.id === baseId); runningLabel = `Currently running: Modified (${story ? story.title : baseId})`; } else { const story = storyPresets.find(s => s.id === state.activeStoryId); runningLabel = `Currently running: ${story ? story.title : state.activeStoryId}`; } } else if (state.isRunning) { runningLabel = 'Currently running: Manual Settings'; } this.setText(this.dom['running-story-label'], runningLabel); this.updateCurrentStatePanel(state, environment); this.updateHistoryVisualization(state, environment); this.drawGraphs(state); this.drawCumulativeGraph(state); this.drawMythographicBar(state, environment, dynamicSettings); }

            // --- Mythographic Bar Drawing (Includes Scanlines) ---
            drawMythographicBar(state, environment, dynamicSettings) {
                if (!this.mythographicBarContext || !this.dom.mythographicBarCanvas) { return; }
                const ctx = this.mythographicBarContext; const canvas = this.dom.mythographicBarCanvas; const width = canvas.width; const height = canvas.height; const turn = state.turn;

                 if (!state.isRunning && !this.isExtinct) { ctx.fillStyle = '#DDD'; ctx.fillRect(0, 0, width, height); ctx.fillStyle = '#AAA'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center'; ctx.fillText("Stopped.", width / 2, height / 2 + 4); this.particles = []; this.clouds = []; this.stars = []; this.lightningFlashFrames = 0; this.isExtinct = false; return; }

                // Layer A: Biome Background
                let biomeColor = '#808080'; const zoneName = environment.getZoneName(); if (zoneName === "Barren") { biomeColor = '#A0522D'; } else if (zoneName === "YoungForest" || zoneName === "MatureForest") { biomeColor = '#006400'; } else if (zoneName === "Wetland") { biomeColor = '#4682B4'; } else if (zoneName === "Grassland") { biomeColor = '#90EE90'; } else if (zoneName === "PioneerScrub") { biomeColor = '#DEB887'; } ctx.fillStyle = biomeColor; ctx.fillRect(0, 0, width, height);
                // Entropy Overlay
                const entropy = state.genomeEntropy; const entropyEnabled = dynamicSettings.genomeEntropyEnabled; if (entropyEnabled && entropy < 2.0) { ctx.fillStyle = 'rgba(210, 230, 255, 0.3)'; ctx.fillRect(0, 0, width, height); } else if (entropyEnabled && entropy > 4.5) { ctx.fillStyle = `rgba(100, 50, 150, ${0.1 + Math.random() * 0.1})`; for (let i = 0; i < 5; i++) { ctx.fillRect(Math.random() * width, Math.random() * height, Math.random() * 30, 1); } }

                // Extinction Effect
                if (this.isExtinct) { ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)'; ctx.lineWidth = 2; for (let i = 0; i < 5; i++) { ctx.beginPath(); ctx.moveTo(Utils.randomInRange(0, width * 0.8), height); ctx.lineTo(Utils.randomInRange(width * 0.1, width * 0.9), Utils.randomInRange(height * 0.2, height * 0.8)); ctx.lineTo(Utils.randomInRange(width * 0.2, width), 0); ctx.stroke(); } ctx.fillStyle = 'rgba(50,50,50, 0.8)'; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center'; ctx.fillText("Silence", width / 2, height / 2 + 6); this.particles = []; this.clouds = []; this.stars = []; } // No return here, draw scanlines over extinction

                // Layer E: Seasonal Overlay
                if (!this.isExtinct) { let seasonTint = 'rgba(0,0,0,0)'; if (turn < 300) { seasonTint = 'rgba(255, 230, 180, 0.1)'; } else if (turn < 800) { seasonTint = 'rgba(255, 255, 210, 0.05)'; } else if (turn < 1200) { seasonTint = 'rgba(200, 180, 220, 0.15)'; } else { seasonTint = 'rgba(180, 190, 200, 0.2)'; } ctx.fillStyle = seasonTint; ctx.fillRect(0, 0, width, height); }

                // Layer C: Celestial Layer (Only if not extinct)
                if (!this.isExtinct) {
                    const fitness = this.currentAvgFitness; const sunX = width * 0.1; const sunY = height * 0.3; const sunBaseRadius = height * 0.18; let sunMultiplier = 1.0; let sunInnerColor = 'rgba(255, 255, 220, 0.9)'; let sunOuterColor = 'rgba(255, 200, 100, 0.5)'; let showRays = false; if (fitness > config.MYTHO_FITNESS_HIGH) { sunMultiplier = 1.2; sunInnerColor = 'rgba(255, 255, 255, 1)'; sunOuterColor = 'rgba(255, 220, 100, 0.7)'; showRays = true; } else if (fitness < config.MYTHO_FITNESS_LOW) { sunMultiplier = 0.7; sunInnerColor = 'rgba(220, 220, 200, 0.7)'; sunOuterColor = 'rgba(180, 180, 180, 0.4)'; } const sunRadius = sunBaseRadius * sunMultiplier; const sunGradient = ctx.createRadialGradient(sunX, sunY, sunRadius * 0.2, sunX, sunY, sunRadius); sunGradient.addColorStop(0, sunInnerColor); sunGradient.addColorStop(1, sunOuterColor); ctx.fillStyle = sunGradient; ctx.beginPath(); ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2); ctx.fill(); if (showRays) { ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)'; ctx.lineWidth = 1.5; for (let i = 0; i < 8; i++) { const angle = (i * Math.PI / 4); const startRadius = sunRadius * 1.1; const endRadius = startRadius * 1.4; ctx.beginPath(); ctx.moveTo(sunX + startRadius * Math.cos(angle), sunY + startRadius * Math.sin(angle)); ctx.lineTo(sunX + endRadius * Math.cos(angle), sunY + endRadius * Math.sin(angle)); ctx.stroke(); } }
                    const entropyDelta = this.currentEntropyDelta30Tick; const moonX = width * 0.9; const moonY = height * 0.3; const moonRadius = height * 0.15; if (entropyEnabled && Math.abs(entropyDelta) > config.MYTHO_BAR_ENTROPY_DELTA_THRESHOLD) { const moonGradient = ctx.createRadialGradient(moonX, moonY, moonRadius * 0.1, moonX, moonY, moonRadius); if (entropyDelta > 0) { moonGradient.addColorStop(0, 'rgba(250, 250, 255, 0.9)'); moonGradient.addColorStop(1, 'rgba(200, 200, 220, 0.6)'); ctx.fillStyle = moonGradient; ctx.beginPath(); ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2); ctx.fill(); } else { moonGradient.addColorStop(0, 'rgba(180, 180, 190, 0.7)'); moonGradient.addColorStop(1, 'rgba(100, 100, 110, 0.5)'); ctx.save(); ctx.fillStyle = moonGradient; ctx.beginPath(); ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = biomeColor; ctx.beginPath(); ctx.arc(moonX - moonRadius * 0.5, moonY, moonRadius * 1.1, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } }
                }

                // Layer B: Sky Layer (Only if not extinct)
                if (!this.isExtinct) {
                    const maxClouds = 10; const baseSpeed = 0.5; const speedMultiplier = Math.max(0.1, Math.min(5, dynamicSettings.successionSpeedMultiplier || 1.0)); const cloudSpeed = baseSpeed * speedMultiplier; const isWindy = (dynamicSettings.disturbanceRateMultiplier || 1.0) > config.MYTHO_DISTURBANCE_RATE_HIGH; if (turn === 1 || this.clouds.length === 0) { this.clouds = []; for (let i = 0; i < maxClouds; i++) { this.clouds.push({ x: Math.random() * width, y: Math.random() * (height * 0.6), size: Utils.randomInRange(15, 40) }); } } ctx.fillStyle = isWindy ? 'rgba(200, 200, 210, 0.6)' : 'rgba(255, 255, 255, 0.6)'; this.clouds.forEach(cloud => { const perspectiveScale = 1.0 - 0.4 * Math.abs(cloud.y - height * 0.3) / (height * 0.3); const currentSize = cloud.size * perspectiveScale; cloud.x += cloudSpeed + (isWindy ? Utils.randomInRange(-0.3, 0.3) : 0); if (cloud.x > width + currentSize) { cloud.x = -currentSize; } ctx.beginPath(); ctx.arc(cloud.x, cloud.y, currentSize * 0.6, Math.PI * 0.5, Math.PI * 1.5); ctx.arc(cloud.x + currentSize * 0.7, cloud.y - currentSize * 0.2, currentSize * 0.7, Math.PI * 1, Math.PI * 1.85); ctx.arc(cloud.x + currentSize * 1.5, cloud.y + currentSize * 0.1, currentSize * 0.5, Math.PI * 1.37, Math.PI * 0.37); ctx.arc(cloud.x + currentSize * 0.7, cloud.y + currentSize * 0.3, currentSize * 0.7, Math.PI * 0, Math.PI * 0.5); ctx.closePath(); ctx.fill(); }); if (isWindy) { ctx.strokeStyle = 'rgba(200, 210, 220, 0.2)'; ctx.lineWidth = 0.5; for(let i=0; i<5; i++){ const startY = Math.random() * height * 0.7; ctx.beginPath(); ctx.moveTo(-20 + Math.random()*40, startY); ctx.lineTo(width + 20 + Math.random()*40, startY + Utils.randomInRange(-5, 5)); ctx.stroke(); } } const mutationRate = dynamicSettings.mutationRate || 0; if (mutationRate > config.MYTHO_BAR_MUTATION_RATE_HIGH) { if (turn % 2 === 0 || this.stars.length === 0) { this.stars = []; const numStars = Math.floor(Utils.randomInRange(15, 40) * (mutationRate / 0.1)); for (let i = 0; i < numStars; i++) { this.stars.push({ x: Math.random() * width, y: (0.1 + Math.random()*0.7) * height * 0.8, brightness: Math.random() }); } } this.stars.forEach(star => { ctx.fillStyle = `rgba(255, 255, 220, ${star.brightness * Math.random()})`; ctx.fillRect(star.x, star.y, 1, 1); }); } else { this.stars = []; }
                }

                // Layer D: Event Particle Layer (Only if not extinct)
                if (!this.isExtinct) {
                    this.particles = this.particles.filter((p) => { p.lifetime--; if (p.lifetime <= 0) return false; p.alpha = p.lifetime / config.MYTHO_PARTICLE_LIFETIME; const perspectiveScale = 1.0 - 0.5 * Math.abs(p.y - height * 0.5) / (height * 0.5); const currentSize = p.size * perspectiveScale; ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color; switch(p.type) { case 'birth': const birthRadius = currentSize * p.alpha; ctx.beginPath(); ctx.arc(p.x, p.y, birthRadius > 0 ? birthRadius : 0.1, 0, Math.PI * 2); ctx.fill(); break; case 'death': p.y += 0.5; ctx.fillRect(p.x - currentSize / 2, p.y - currentSize / 2, currentSize, currentSize); break; case 'mutation': const flashSize = currentSize * (1 + (1 - p.alpha)); ctx.fillRect(p.x - flashSize / 2, p.y - flashSize / 2, flashSize, flashSize); break; } ctx.globalAlpha = 1.0; return true; });
                }

                // Lightning Effect (Only if not extinct)
                if (!this.isExtinct && this.lightningFlashFrames > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * (this.lightningFlashFrames / config.MYTHO_LIGHTNING_FLASH_FRAMES)})`; ctx.fillRect(0, 0, width, height); this.lightningFlashFrames--; }

                // --- Scanline Overlay (Draw Last, Always) ---
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Slightly darker scanlines
                ctx.lineWidth = 1; // Keep it thin
                for (let y = 1; y < height; y += 2) {
                    ctx.beginPath();
                    ctx.moveTo(0, y + 0.5); // Offset by 0.5 for sharper lines
                    ctx.lineTo(width, y + 0.5);
                    ctx.stroke();
                }
            }
            // --- End Mythographic Bar Drawing ---

            addParticles(count, type) { const limit = config.MYTHO_MAX_PARTICLES_PER_TICK; const numToAdd = Math.min(count, limit); const canvas = this.dom.mythographicBarCanvas; if (!canvas) return; const width = canvas.width; const height = canvas.height; for (let i = 0; i < numToAdd; i++) { const randomY = (Math.random() + Math.random()) / 2; let p = { x: Math.random() * width, y: randomY * height, lifetime: config.MYTHO_PARTICLE_LIFETIME, alpha: 1.0, type: type, size: 0, color: '#fff' }; switch(type) { case 'birth': p.size = Utils.randomInRange(2, 4); p.color = '#87CEEB'; p.y = (0.5 + Math.random() * 0.5) * height; break; case 'death': p.size = Utils.randomInRange(2, 3); p.color = '#A0522D'; p.y = (Math.random() * 0.8) * height; break; case 'mutation': p.size = Utils.randomInRange(3, 5); p.color = '#FFFF99'; break; } this.particles.push(p); } }
            setText(element, value) { if (element) { element.innerHTML = String(value); } }
            setDisabled(element, isDisabled) { if (element) { element.disabled = isDisabled; } }
            getZoneColor(zoneName) { switch (zoneName) { case "Barren": return "#A0522D"; case "PioneerScrub": return "#DEB887"; case "Grassland": return "#90EE90"; case "YoungForest": return "#228B22"; case "MatureForest": return "#006400"; case "Wetland": return "#4682B4"; default: return "#808080"; } }
            getPopulationColor(popCount, maxPop) { if (maxPop <= 0 || popCount <= 0) return "#000"; const ratio = Math.min(1, Math.max(0, popCount / maxPop)); const value = Math.floor(ratio * 255); return `rgb(${value},${value},${value})`; }
            getFitnessColor(fitness) { const clampedFitness = Math.min(1, Math.max(0, fitness)); let r, g, b = 0; if (clampedFitness < 0.5) { r = 255; g = Math.floor(255 * (clampedFitness / 0.5)); } else { r = Math.floor(255 * (1 - (clampedFitness - 0.5) / 0.5)); g = 255; } return `rgb(${r},${g},${b})`; }
            getLifespanColor(multiplier) { const minMult = 0.5, maxMult = 2.0; const clampedMult = Math.max(minMult, Math.min(maxMult, multiplier)); const normalized = (clampedMult - minMult) / (maxMult - minMult); let r, g, b; if (normalized < 0.5) { const ratio = normalized / 0.5; r = Math.floor(255 * ratio); g = Math.floor(255 * ratio); b = 255; } else { const ratio = (normalized - 0.5) / 0.5; r = 255; g = Math.floor(255 * (1 - ratio) + 165 * ratio); b = Math.floor(255 * (1 - ratio) + 0 * ratio); } return `rgb(${r},${g},${b})`; }
            getDominantFocusInfo(avgPhenotype, idealTraits) { if (!avgPhenotype || !idealTraits || avgPhenotype.calculatedTurn < 0) { return { color: "#808080", text: "N/A" }; } const avgE = avgPhenotype.E ?? 0; const avgM = avgPhenotype.M ?? 0; const avgR = avgPhenotype.R ?? 0; const idealE = idealTraits.ideal_efficiency ?? 0.5; const idealM = idealTraits.ideal_mobility ?? 0.5; const idealR = idealTraits.ideal_resilience ?? 0.5; const diffE = Math.abs(avgE - idealE); const diffM = Math.abs(avgM - idealM); const diffR = Math.abs(avgR - idealR); const minDiff = Math.min(diffE, diffM, diffR); const tolerance = 0.001; let minCount = 0; let focus = []; let color = "#808080"; if (Math.abs(diffE - minDiff) < tolerance) { minCount++; focus.push("Efficiency"); color = "#87CEEB"; } if (Math.abs(diffM - minDiff) < tolerance) { minCount++; focus.push("Mobility"); color = "#FFD700"; } if (Math.abs(diffR - minDiff) < tolerance) { minCount++; focus.push("Resilience"); color = "#FA8072"; } if (minCount > 1) { return { color: "#C0C0C0", text: "Mixed" }; } else if (minCount === 1) { return { color: color, text: focus[0] }; } else { return { color: "#808080", text: "Undefined" }; } }
            updateHistoryVisualization(state, environment) { if (!this.historyVisContext || !this.dom.historyVis) return; const ctx = this.historyVisContext; const canvasWidth = this.dom.historyVis.width; const turn = state.turn; const turnsWidth = canvasWidth / 2; const x = (turn % turnsWidth) * 2; const zoneName = environment?.getZoneName() || "?"; const popCount = state.organisms.length; const avgPhenotype = state.averagePhenotype; const currentAvgFitness = (avgPhenotype && avgPhenotype.calculatedTurn === turn) ? avgPhenotype.F : 0; const idealTraits = environment?.getParams(); const focusInfo = this.getDominantFocusInfo(avgPhenotype, idealTraits); ctx.fillStyle = this.getZoneColor(zoneName); ctx.fillRect(x, 0, 2, 2); ctx.fillStyle = this.getPopulationColor(popCount, config.POPULATION_CAP); ctx.fillRect(x, 2, 2, 2); ctx.fillStyle = this.getFitnessColor(currentAvgFitness); ctx.fillRect(x, 4, 2, 2); ctx.fillStyle = this.getLifespanColor(avgPhenotype?.L ?? 1.0); ctx.fillRect(x, 6, 2, 2); ctx.fillStyle = focusInfo.color; ctx.fillRect(x, 8, 2, 2); }
            updateCurrentStatePanel(state, environment) { if (!this.dom.currentStateZoneColor) return; const zoneName = environment?.getZoneName() || "N/A"; const popCount = state.organisms.length; const avgPhenotype = state.averagePhenotype; const currentAvgFitness = (avgPhenotype && avgPhenotype.calculatedTurn === state.turn) ? avgPhenotype.F : 0; const idealTraits = environment?.getParams(); const focusInfo = this.getDominantFocusInfo(avgPhenotype, idealTraits); this.dom.currentStateZoneColor.style.backgroundColor = this.getZoneColor(zoneName); this.setText(this.dom.currentStateZoneValue, zoneName); this.dom.currentStatePopColor.style.backgroundColor = this.getPopulationColor(popCount, config.POPULATION_CAP); this.setText(this.dom.currentStatePopValue, `${popCount}/${config.POPULATION_CAP}`); this.dom.currentStateFitnessColor.style.backgroundColor = this.getFitnessColor(currentAvgFitness); this.setText(this.dom.currentStateFitnessValue, (popCount > 0 && typeof currentAvgFitness === 'number') ? currentAvgFitness.toFixed(3) : "N/A"); const avgL = (avgPhenotype && avgPhenotype.calculatedTurn >= 0) ? avgPhenotype.L : 1.0; this.dom.currentStateLifespanColor.style.backgroundColor = this.getLifespanColor(avgL); this.setText(this.dom.currentStateLifespanValue, (avgPhenotype && avgPhenotype.calculatedTurn >= 0) ? `${avgL.toFixed(2)}x` : "N/A"); this.dom.currentStateFocusColor.style.backgroundColor = focusInfo.color; this.setText(this.dom.currentStateFocusValue, focusInfo.text); }
            drawGraphs(state) { if (!this.coreGraphContext || !this.dom.coreGraphCanvas) return; const ctx = this.coreGraphContext; const width = this.dom.coreGraphCanvas.width; const height = this.dom.coreGraphCanvas.height; const popHistory = state.smoothedPopHistory; const fitHistory = state.smoothedFitnessHistory; const numPoints = popHistory.length; ctx.fillStyle = '#FFF'; ctx.fillRect(0, 0, width, height); ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0.5, 0); ctx.lineTo(0.5, height); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, height - 0.5); ctx.lineTo(width, height - 0.5); ctx.stroke(); const fitMidY = height * (1 - 0.5); ctx.beginPath(); ctx.moveTo(0, fitMidY + 0.5); ctx.lineTo(width, fitMidY + 0.5); ctx.stroke(); if (numPoints > 1) { ctx.strokeStyle = '#3498db'; ctx.lineWidth = 1.5; ctx.beginPath(); for (let i = 0; i < numPoints; i++) { const x = (i / (config.GRAPH_WINDOW_SIZE - 1)) * width; const y = height * (1 - (popHistory[i] / config.POPULATION_CAP)); if (i === 0) { ctx.moveTo(x, y); } else { ctx.lineTo(x, y); } } ctx.stroke(); } if (numPoints > 1) { ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 1.5; ctx.beginPath(); for (let i = 0; i < numPoints; i++) { const x = (i / (config.GRAPH_WINDOW_SIZE - 1)) * width; const y = height * (1 - fitHistory[i]); if (i === 0) { ctx.moveTo(x, y); } else { ctx.lineTo(x, y); } } ctx.stroke(); } }
            drawCumulativeGraph(state) { if (!this.cumulativeGraphContext || !this.dom.cumulativeGraphCanvas) return; const ctx = this.cumulativeGraphContext; const width = this.dom.cumulativeGraphCanvas.width; const height = this.dom.cumulativeGraphCanvas.height; const bornHistory = state.totalBornHistory; const mutationHistory = state.totalMutationsHistory; const deathHistory = state.totalDeathsHistory; const numPoints = bornHistory.length; ctx.fillStyle = '#FFF'; ctx.fillRect(0, 0, width, height); let yMax = 10; if (numPoints > 0) { const visibleBorn = bornHistory.slice(-config.GRAPH_WINDOW_SIZE); const visibleMut = mutationHistory.slice(-config.GRAPH_WINDOW_SIZE); const visibleDeaths = deathHistory.slice(-config.GRAPH_WINDOW_SIZE); const maxInWindow = Math.max(Math.max(...visibleBorn.filter(v=>!isNaN(v)&&isFinite(v))), Math.max(...visibleMut.filter(v=>!isNaN(v)&&isFinite(v))), Math.max(...visibleDeaths.filter(v=>!isNaN(v)&&isFinite(v)))); yMax = Math.max(yMax, maxInWindow); } yMax = Math.ceil(yMax * 1.05); if (yMax <= 0 || !isFinite(yMax)) yMax = 10; this.setText(this.dom.cumulativeYMaxLabel, `(YMax:${yMax})`); ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0.5, 0); ctx.lineTo(0.5, height); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, height - 0.5); ctx.lineTo(width, height - 0.5); ctx.stroke(); const drawLine = (history, color) => { if (numPoints > 1) { ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.beginPath(); for (let i = 0; i < numPoints; i++) { const x = (i / (config.GRAPH_WINDOW_SIZE - 1)) * width; const val = history[i]; const scaledY = (yMax > 0 && isFinite(val)) ? (val / yMax) : 0; const y = height * (1 - Math.min(1, Math.max(0, scaledY))); if (i === 0) { ctx.moveTo(x, y); } else { ctx.lineTo(x, y); } } ctx.stroke(); } }; drawLine(bornHistory, '#2ecc71'); drawLine(mutationHistory, '#9b59b6'); drawLine(deathHistory, '#7f8c8d'); }
            updateSpotlightTarget(text) { this.setText(this.dom.spotlightTarget, text); }
            displaySpotlightLineage(lineageHtml) { if (this.dom['spotlight-output']) { this.dom['spotlight-output'].innerHTML = lineageHtml; this.dom['spotlight-output'].classList.add('lineage-visible'); this.setText(this.dom.toggleLineageButton, "[Hide Lineage]"); } }
            toggleLineageDisplay() { if (!this.dom['spotlight-output'] || !this.dom.toggleLineageButton) return; const isVisible = this.dom['spotlight-output'].classList.contains('lineage-visible'); if (isVisible) { this.dom['spotlight-output'].classList.remove('lineage-visible'); this.setText(this.dom.toggleLineageButton, "[Show Lineage]"); } else { this.dom['spotlight-output'].classList.add('lineage-visible'); this.setText(this.dom.toggleLineageButton, "[Hide Lineage]"); } }
            updateSliderDisplay(sliderId, valueId, suffix = '', multiplier = 1, fixedDigits = undefined) { if (this.dom[sliderId] && this.dom[valueId]) { let value = parseFloat(this.dom[sliderId].value) * multiplier; if (fixedDigits !== undefined) { value = value.toFixed(fixedDigits); } this.setText(this.dom[valueId], `${value}${suffix}`); } }
            updateAllSliderDisplays() { this.updateSliderDisplay('resourceMultiplierSlider', 'resourceMultiplierValue', '%'); this.updateSliderDisplay('mutationRateSlider', 'mutationRateValue', '%'); this.updateSliderDisplay('successionSpeedSlider', 'successionSpeedValue', 'x', 1, 1); this.updateSliderDisplay('disturbanceRateSlider', 'disturbanceRateValue', 'x', 1, 1); this.updateSliderDisplay('peffIntensitySlider', 'peffIntensityValue', '', 1, 3); }
            getDynamicSettings() { const settings = {}; settings.resourceMultiplier = this.dom.resourceMultiplierSlider ? parseFloat(this.dom.resourceMultiplierSlider.value) / 100.0 : 1.0; settings.mutationRate = this.dom.mutationRateSlider ? parseFloat(this.dom.mutationRateSlider.value) / 100.0 : config.DEFAULT_MUTATION_RATE; settings.successionSpeedMultiplier = this.dom.successionSpeedSlider ? parseFloat(this.dom.successionSpeedSlider.value) : 1.0; settings.disturbanceRateMultiplier = this.dom.disturbanceRateSlider ? parseFloat(this.dom.disturbanceRateSlider.value) : 1.0; settings.peffIntensity = this.dom.peffIntensitySlider ? parseFloat(this.dom.peffIntensitySlider.value) : config.DEFAULT_PEFF_SHIFT_MAGNITUDE; settings.fitnessCurve = this.dom.fitnessCurveSelect ? this.dom.fitnessCurveSelect.value : 'balanced'; settings.observerMode = this.dom.observerModeSelect ? this.dom.observerModeSelect.value : 'reflective'; settings.genomeEntropyEnabled = this.dom.genomeEntropyToggle ? this.dom.genomeEntropyToggle.checked : false; switch (settings.fitnessCurve) { case 'neutral': settings.deathThreshold = 0.05; settings.reproductionThreshold = 0.40; break; case 'harsh': settings.deathThreshold = 0.25; settings.reproductionThreshold = 0.75; break; case 'balanced': default: settings.deathThreshold = config.DEFAULT_DEATH_THRESHOLD; settings.reproductionThreshold = config.DEFAULT_REPRODUCTION_THRESHOLD; break; } return settings; }
            populateStoryPresets() { const storyListDiv = this.dom['story-list']; if (!storyListDiv) return; storyListDiv.innerHTML = ''; storyPresets.forEach(preset => { const item = document.createElement('div'); item.classList.add('story-preset-item'); item.innerHTML = ` <h3 title="${preset.id}">${preset.title}</h3> <p class="story-hook" title="Narrative hook for this preset.">${preset.hook}</p> <p class="story-summary" title="Key parameter settings summary.">Params: ${preset.summary}</p> <button class="story-load-button" data-preset-id="${preset.id}" title="Load '${preset.title}' settings into Manual Tuning Controls below.">Load Settings</button> `; storyListDiv.appendChild(item); }); }
            applyPresetToControls(presetId) { const preset = storyPresets.find(p => p.id === presetId); if (!preset) { console.warn(`Preset ${presetId} not found`); return false; } if (this.dom.resourceMultiplierSlider) { this.dom.resourceMultiplierSlider.value = preset.parameters.resourceMultiplier * 100; this.updateSliderDisplay('resourceMultiplierSlider', 'resourceMultiplierValue', '%'); } if (this.dom.mutationRateSlider) { this.dom.mutationRateSlider.value = preset.parameters.mutationRate * 100; this.updateSliderDisplay('mutationRateSlider', 'mutationRateValue', '%'); } if (this.dom.successionSpeedSlider) { this.dom.successionSpeedSlider.value = preset.parameters.successionSpeedMultiplier; this.updateSliderDisplay('successionSpeedSlider', 'successionSpeedValue', 'x', 1, 1); } if (this.dom.disturbanceRateSlider) { this.dom.disturbanceRateSlider.value = preset.parameters.disturbanceRateMultiplier; this.updateSliderDisplay('disturbanceRateSlider', 'disturbanceRateValue', 'x', 1, 1); } if (this.dom.peffIntensitySlider) { this.dom.peffIntensitySlider.value = preset.parameters.peffIntensity; this.updateSliderDisplay('peffIntensitySlider', 'peffIntensityValue', '', 1, 3); } if (this.dom.fitnessCurveSelect) { this.dom.fitnessCurveSelect.value = preset.parameters.fitnessCurve; } if (this.dom.genomeEntropyToggle) { this.dom.genomeEntropyToggle.checked = preset.parameters.genomeEntropyEnabled; } console.log(`Applied preset ${presetId} parameters to controls.`); document.querySelectorAll('.story-load-button').forEach(btn => { btn.classList.remove('loaded'); btn.textContent = 'Load Settings'; }); const clickedButton = document.querySelector(`.story-load-button[data-preset-id="${presetId}"]`); if (clickedButton) { clickedButton.classList.add('loaded'); clickedButton.textContent = 'Settings Loaded'; } return true; }
            resetStoryLoadButtons() { document.querySelectorAll('.story-load-button').forEach(btn => { btn.classList.remove('loaded'); btn.textContent = 'Load Settings'; }); }
            displayFloatingMythos(text) { if (!this.dom['mythos-overlay'] || !text) return; const overlay = this.dom['mythos-overlay']; const floater = document.createElement('div'); floater.classList.add('mythos-floater'); floater.textContent = text; const randX = Utils.randomInRange(10, 60); const randY = Utils.randomInRange(10, 80); floater.style.left = `${randX}%`; floater.style.top = `${randY}%`; floater.style.transitionDuration = `${config.MYTHOS_FADE_DURATION_MS / 1000}s`; overlay.appendChild(floater); requestAnimationFrame(() => { requestAnimationFrame(() => { floater.style.opacity = '0.6'; }); }); setTimeout(() => { floater.style.opacity = '0'; setTimeout(() => { if (overlay.contains(floater)) { overlay.removeChild(floater); } }, config.MYTHOS_FADE_DURATION_MS); }, config.MYTHOS_FLOAT_DURATION_MS - config.MYTHOS_FADE_DURATION_MS); }
            showSaveReportButton() { if (this.dom.saveReportButton) this.dom.saveReportButton.style.display = 'block'; }
            hideSaveReportButton() { if (this.dom.saveReportButton) this.dom.saveReportButton.style.display = 'none'; }
        }

        // --- MODULES (Identical to 9.8 / 10.2html) ---
        const MutationEngine = { init(dependencies) { this.config = dependencies.config; this.utils = dependencies.utils; this.logger = dependencies.logger; this.dynamicSettings = dependencies.dynamicSettings; }, applyMutation(genome, turn) { if (!this.config || !this.utils || !this.logger || !this.dynamicSettings) { return { mutated: false, newGenome: genome }; } if (typeof genome !== 'string' || genome.length < this.config.MIN_GENOME_LENGTH) { return { mutated: false, newGenome: genome }; } if (Math.random() >= this.dynamicSettings.mutationRate) { return { mutated: false, newGenome: genome }; } const mutationRand = Math.random(); let cumulativeProb = 0; let mutationType = 'point'; for (const [type, prob] of Object.entries(this.config.MUTATION_TYPE_PROBS)) { cumulativeProb += prob; if (mutationRand < cumulativeProb) { mutationType = type; break; } } let mutationResult = {}; try { switch (mutationType) { case 'point': mutationResult = this._point(genome); break; case 'insertion': mutationResult = this._insertion(genome); break; case 'deletion': mutationResult = this._deletion(genome); break; case 'swap': mutationResult = this._swap(genome); break; default: mutationResult = { newGenome: genome, description: "Unknown" }; break; } } catch (e) { return { mutated: false, newGenome: genome }; } const { newGenome, description } = mutationResult; if (typeof newGenome !== 'string' || newGenome.length < this.config.MIN_GENOME_LENGTH || newGenome.length > this.config.MAX_GENOME_LENGTH) { return { mutated: false, newGenome: genome }; } if (newGenome !== genome) { this.logger.log(turn, "Mutation", description || `Mutation (${mutationType})`, { oldGenome: genome, newGenome: newGenome }); return { mutated: true, newGenome: newGenome }; } else { return { mutated: false, newGenome: genome }; } }, _point: (g) => { if (typeof g !== 'string' || g.length === 0) return { newGenome: g, description: "Point skip"}; const i = Math.floor(Math.random() * g.length); const oC = g[i]; let nC = Utils.randomChar(); while (nC === oC && g.length > 0) { nC = Utils.randomChar(); } const nG = g.substring(0, i) + nC + g.substring(i + 1); return { newGenome: nG, description: `Point @ ${i} ('${oC}'->'${nC}')`}; }, _insertion: (g) => { if (typeof g !== 'string') return { newGenome: g, description: "Insert skip" }; if (g.length >= config.MAX_GENOME_LENGTH) return { newGenome: g, description: `Insert skip (max)` }; const i = Math.floor(Math.random() * (g.length + 1)); const cI = Utils.randomChar(); const nG = g.substring(0, i) + cI + g.substring(i); return { newGenome: nG, description: `Insert '${cI}' @ ${i}` }; }, _deletion: (g) => { if (typeof g !== 'string') return { newGenome: g, description: "Delete skip" }; if (g.length <= config.MIN_GENOME_LENGTH) return { newGenome: g, description: `Delete skip (min)` }; if (g.length === 0) return { newGenome: g, description: "Delete skip (empty)"}; const i = Math.floor(Math.random() * g.length); const dC = g[i]; const nG = g.substring(0, i) + g.substring(i + 1); return { newGenome: nG, description: `Delete '${dC}' @ ${i}` }; }, _swap: (g) => { if (typeof g !== 'string' || g.length < 2) return { newGenome: g, description: "Swap skip" }; let i1 = Math.floor(Math.random() * g.length); let i2 = Math.floor(Math.random() * g.length); while (i1 === i2) { i2 = Math.floor(Math.random() * g.length); } if (i1 > i2) [i1, i2] = [i2, i1]; const c1 = g[i1]; const c2 = g[i2]; const gA = g.split(''); gA[i1] = c2; gA[i2] = c1; const nG = gA.join(''); return { newGenome: nG, description: `Swap @ ${i1}<->${i2}`}; } };
        const SynergyEngine = { init(dependencies) { this.config = dependencies.config; this.logger = dependencies.logger; }, calculateModifier(organism, phenotype, genome, baseFitness, turn) { if (!this.config || !this.logger) { return 0; } if (!this.config.TSE_ENABLED) return 0; let totalModifier = 0; const T = this.config.TSE_THRESHOLDS; const M = this.config.TSE_MODIFIERS; const eff = phenotype?.efficiency ?? 0; const mob = phenotype?.mobility ?? 0; const res = phenotype?.resilience ?? 0; const len = genome?.length ?? 0; let currentSynergyReason = "None"; if (mob > T.HIGH_MOBILITY && eff > T.HIGH_EFFICIENCY) { totalModifier += M.BURST_ECOTYPE; currentSynergyReason = "Burst"; } else if (res > T.HIGH_RESILIENCE && eff < T.LOW_EFFICIENCY) { totalModifier += M.TANK_FORM; currentSynergyReason = "Tank"; } if (len < T.SHORT_GENOME) { totalModifier += M.STREAMLINED; if (currentSynergyReason === "None") currentSynergyReason = "Streamlined"; else currentSynergyReason += "/Streamlined"; } else if (len > T.LONG_GENOME && res < T.BLOATED_RESILIENCE_REQ) { totalModifier += M.BLOATED; if (currentSynergyReason === "None") currentSynergyReason = "Bloated"; else currentSynergyReason += "/Bloated"; } const cappedModifier = Math.max(-this.config.TSE_MAX_MODIFIER, Math.min(this.config.TSE_MAX_MODIFIER, totalModifier)); const lastModifier = organism.lastAppliedSynergyModifier || 0; if (cappedModifier !== lastModifier) { const logThreshold = this.config.TSE_LOG_THRESHOLD; if (Math.abs(cappedModifier) >= logThreshold || Math.abs(lastModifier) >= logThreshold) { const displayReason = (Math.abs(cappedModifier) < logThreshold && cappedModifier !== 0) ? `${currentSynergyReason}(sub)` : (cappedModifier === 0 ? "None" : currentSynergyReason); this.logger.log(turn, "System", `Synergy: ${displayReason} -> Mod ${cappedModifier.toFixed(3)}`, { synergyMod: cappedModifier }); } organism.lastAppliedSynergyModifier = cappedModifier; } return cappedModifier; } };
        const Observer = { init(dependencies) { this.config = dependencies.config; this.utils = dependencies.utils; this.logger = dependencies.logger; this.dynamicSettings = dependencies.dynamicSettings; this.snapshot = this.resetSnapshot(); this.DESCRIPTORS = { largeIncrease: ["sig increase", "marked rise", "jump"], increase: ["mod increase", "rise", "growth"], slightIncrease: ["slight uptick", "marginal gain", "minor increase"], stable: ["stable", "unchanged", "steady"], slightDecrease: ["minor decrease", "marginal drop", "slight decline"], decrease: ["drop", "decline", "reduction"], largeDecrease: ["sig decrease", "sharp drop", "fall"] }; this.TRAIT_LABELS = { Efficiency: ["efficiency", "conversion"], Mobility: ["mobility", "movement"], Resilience: ["resilience", "durability"], Mixed: ["mixed traits", "adaptability"], Undefined: ["undefined focus", "drift"] }; this.MUTATION_LEVEL = { veryLow: ["minimal", "negligible"], low: ["low", "reduced"], medium: ["moderate", "typical"], high: ["elevated", "increased"], veryHigh: ["high", "significant"] }; this.DEATH_FOCUS = { 'Old Age': ["senescence"], 'Starvation': ["scarcity"], 'Low Fitness': ["maladaptation"], 'Cap Cull': ["density"], 'Disturbance Cull': ["disturbance"], 'Unknown': ["various factors"] }; this.SENTENCE_STRUCTURES = [ (pop, fit) => `Pop ${pop}. Fit ${fit}.`, (pop, fit) => `Obs: ${pop} pop, ${fit} fitness.`, (pop, fit) => `Dynamic: ${pop}; ${fit}.` ]; this.CONNECTORS = ["; ", ". ", ", ", ". Also, "]; }, resetSnapshot() { return { turn: -1, population: 0, avgFitness: 0.0, avgPhenotype: { E: 0, M: 0, R: 0, L: 1.0, F: 0.0, calculatedTurn: -1 }, dominantFocus: 'N/A', zoneName: 'N/A', totalMutations: 0, totalDeathsByReason: { 'Old Age': 0, 'Starvation': 0, 'Low Fitness': 0, 'Cap Cull': 0, 'Disturbance Cull': 0, 'Unknown': 0 } }; }, maybeGenerateReport(currentState, currentEnvironment, uiManager) { if (!this.config || !this.utils || !this.logger || !this.dynamicSettings || !currentState || !currentEnvironment || !uiManager) { return; } const currentTurn = currentState.turn; const observerMode = this.dynamicSettings.observerMode; let reportInterval = this.config.DEFAULT_OBSERVER_INTERVAL; if (observerMode === 'minimal') { reportInterval *= 2; } else if (observerMode === 'cold' || observerMode === 'reflective') { reportInterval = this.config.DEFAULT_OBSERVER_INTERVAL; } if (currentTurn === 0 || currentTurn % reportInterval !== 0) { return; } if (this.snapshot.turn === -1) { this.updateSnapshot(currentState, currentEnvironment, uiManager); return; } const currentPopulation = currentState.organisms.length; const currentAvgPhenotype = currentState.averagePhenotype; const currentAvgFitness = currentAvgPhenotype.F; const currentZoneName = currentEnvironment.getZoneName(); const currentTotalMutations = currentState.totalMutations; const currentDeathsByReason = { 'Old Age': currentState.totalOldAgeDeaths, 'Starvation': currentState.totalStarvationDeaths, 'Low Fitness': currentState.totalLowFitnessDeaths, 'Cap Cull': currentState.totalCapCulls, 'Disturbance Cull': currentState.totalDisturbanceCulls }; const focusInfo = uiManager.getDominantFocusInfo(currentAvgPhenotype, currentEnvironment.getParams()); const currentDominantFocus = focusInfo.text; const interval = currentTurn - this.snapshot.turn; if (interval <= 0) { this.updateSnapshot(currentState, currentEnvironment, uiManager); return; } const popDelta = currentPopulation - this.snapshot.population; const fitnessDelta = currentAvgFitness - this.snapshot.avgFitness; const mutationCountWindow = currentTotalMutations - this.snapshot.totalMutations; let deathsWindowByReason = {}; let totalDeathsWindow = 0; for (const reason in currentDeathsByReason) { if (Object.prototype.hasOwnProperty.call(currentDeathsByReason, reason)) { const windowDeaths = (currentDeathsByReason[reason] || 0) - (this.snapshot.totalDeathsByReason[reason] || 0); deathsWindowByReason[reason] = windowDeaths; totalDeathsWindow += windowDeaths; } } let popDesc = this.utils.getRandomElement(this.DESCRIPTORS.stable); const popChangePercent = this.snapshot.population > 0 ? (popDelta / this.snapshot.population) * 100 : (currentPopulation > 0 ? 100 : 0); if (popChangePercent > 25) popDesc = this.utils.getRandomElement(this.DESCRIPTORS.largeIncrease); else if (popChangePercent > 5) popDesc = this.utils.getRandomElement(this.DESCRIPTORS.increase); else if (popChangePercent > 1) popDesc = this.utils.getRandomElement(this.DESCRIPTORS.slightIncrease); else if (popChangePercent < -25) popDesc = this.utils.getRandomElement(this.DESCRIPTORS.largeDecrease); else if (popChangePercent < -5) popDesc = this.utils.getRandomElement(this.DESCRIPTORS.decrease); else if (popChangePercent < -1) popDesc = this.utils.getRandomElement(this.DESCRIPTORS.slightDecrease); let fitnessDesc = this.utils.getRandomElement(this.DESCRIPTORS.stable); const fitChangeThreshold = 0.03; if (fitnessDelta > fitChangeThreshold * 2) fitnessDesc = this.utils.getRandomElement(this.DESCRIPTORS.largeIncrease); else if (fitnessDelta > fitChangeThreshold) fitnessDesc = this.utils.getRandomElement(this.DESCRIPTORS.increase); else if (fitnessDelta > fitChangeThreshold / 3) fitnessDesc = this.utils.getRandomElement(this.DESCRIPTORS.slightIncrease); else if (fitnessDelta < -fitChangeThreshold * 2) fitnessDesc = this.utils.getRandomElement(this.DESCRIPTORS.largeDecrease); else if (fitnessDelta < -fitChangeThreshold) fitnessDesc = this.utils.getRandomElement(this.DESCRIPTORS.decrease); else if (fitnessDelta < -fitChangeThreshold / 3) fitnessDesc = this.utils.getRandomElement(this.DESCRIPTORS.slightDecrease); const avgPopEstimate = (this.snapshot.population + currentPopulation) / 2; const avgMutRatePerOrgTurn = (avgPopEstimate > 0 && interval > 0) ? (mutationCountWindow / (avgPopEstimate * interval)) : 0; let mutLevelDesc = this.utils.getRandomElement(this.MUTATION_LEVEL.medium); const baseRate = this.dynamicSettings.mutationRate; if (avgMutRatePerOrgTurn > baseRate * 1.5) mutLevelDesc = this.utils.getRandomElement(this.MUTATION_LEVEL.veryHigh); else if (avgMutRatePerOrgTurn > baseRate * 1.1) mutLevelDesc = this.utils.getRandomElement(this.MUTATION_LEVEL.high); else if (avgMutRatePerOrgTurn < baseRate * 0.5) mutLevelDesc = this.utils.getRandomElement(this.MUTATION_LEVEL.veryLow); else if (avgMutRatePerOrgTurn < baseRate * 0.9) mutLevelDesc = this.utils.getRandomElement(this.MUTATION_LEVEL.low); let dominantDeathCause = null; let maxDeathPercent = 0; if (totalDeathsWindow > 5) { for (const reason in deathsWindowByReason) { if (Object.prototype.hasOwnProperty.call(deathsWindowByReason, reason)) { const percent = (deathsWindowByReason[reason] / totalDeathsWindow) * 100; if (percent > 40 && percent > maxDeathPercent) { maxDeathPercent = percent; dominantDeathCause = reason; } } } } let reportSentences = []; const popFitTemplate = this.utils.getRandomElement(this.SENTENCE_STRUCTURES); reportSentences.push(popFitTemplate(popDesc, fitnessDesc)); if (observerMode !== 'minimal') { let traitPhrase = ""; const currentTraitLabel = this.utils.getRandomElement(this.TRAIT_LABELS[currentDominantFocus] || this.TRAIT_LABELS['Undefined']); const dominantFocusChanged = currentDominantFocus !== this.snapshot.dominantFocus; if (dominantFocusChanged && this.snapshot.dominantFocus !== 'N/A') { const prevTraitLabel = this.utils.getRandomElement(this.TRAIT_LABELS[this.snapshot.dominantFocus] || this.TRAIT_LABELS['Undefined']); traitPhrase = `Focus shift ${prevTraitLabel}->${currentTraitLabel}.`; } else if (currentDominantFocus !== 'N/A') { const stabilityWord = ["remains", "centers on"][Math.floor(Math.random() * 2)]; traitPhrase = `Focus ${stabilityWord} ${currentTraitLabel}.`; } else { traitPhrase = "No clear focus."; } const mutationPhrase = `Mut ${mutLevelDesc}.`; reportSentences.push(`${traitPhrase}${this.utils.getRandomElement(this.CONNECTORS)}${mutationPhrase}`); let deathPhrase = ""; if (dominantDeathCause) { const deathLabel = this.utils.getRandomElement(this.DEATH_FOCUS[dominantDeathCause] || [dominantDeathCause]); const qualifier = ["prim", "mostly"][Math.floor(Math.random()*2)]; deathPhrase = `Deaths ${qualifier} ${deathLabel} (${maxDeathPercent.toFixed(0)}%).`; } let zonePhrase = ""; const zoneChanged = currentZoneName !== this.snapshot.zoneName; if (zoneChanged) { zonePhrase = `Env->${currentZoneName}.`; } else { const timeInZone = currentEnvironment?.getTimeInStage() || 0; if (timeInZone > interval * 1.5) { const stabilityDesc = ["stable", "persists"][Math.floor(Math.random()*2)]; zonePhrase = `Env ${stabilityDesc} in ${currentZoneName}.`; } } if (deathPhrase && zonePhrase) { reportSentences.push(`${deathPhrase}${this.utils.getRandomElement(this.CONNECTORS)}${zonePhrase}`); } else if (deathPhrase) { reportSentences.push(deathPhrase); } else if (zonePhrase) { reportSentences.push(zonePhrase); } } const fullReport = reportSentences.join(' '); this.logger.log(currentTurn, "Observer", fullReport); this.updateSnapshot(currentState, currentEnvironment, uiManager); }, updateSnapshot(currentState, currentEnvironment, uiManager) { const currentAvgPhenotype = currentState.averagePhenotype; const focusInfo = uiManager.getDominantFocusInfo(currentAvgPhenotype, currentEnvironment.getParams()); const currentDeathsByReason = { 'Old Age': currentState.totalOldAgeDeaths, 'Starvation': currentState.totalStarvationDeaths, 'Low Fitness': currentState.totalLowFitnessDeaths, 'Cap Cull': currentState.totalCapCulls, 'Disturbance Cull': currentState.totalDisturbanceCulls, 'Unknown': 0 }; this.snapshot = { turn: currentState.turn, population: currentState.organisms.length, avgFitness: currentAvgPhenotype.F, avgPhenotype: { ...currentAvgPhenotype }, dominantFocus: focusInfo.text, zoneName: currentEnvironment.getZoneName(), totalMutations: currentState.totalMutations, totalDeathsByReason: { ...currentDeathsByReason } }; } };
        class Environment { constructor(zoneSequence, baseZoneDefinitions, successionTimerBase, resourceMultiplier, dependencies) { this.zoneSequence = zoneSequence; this.baseZoneDefinitions = baseZoneDefinitions; this.successionTimerBase = successionTimerBase; this.config = dependencies.config; this.logger = dependencies.logger; this.dynamicSettings = dependencies.dynamicSettings; this.currentZoneIndex = 0; this.timeInStage = 0; this.multiplier = Math.max(0, resourceMultiplier); this.currentZoneParams = this._createMutableZoneParams(this.currentZoneIndex); this.effectiveInitialResources = 0; this.effectiveRegenRate = 0; this.currentResources = 0; this._updateEffectiveResources(); } _createMutableZoneParams(zoneIndex) { const baseDef = this._getOriginalZoneDefinition(zoneIndex); return JSON.parse(JSON.stringify(baseDef)); } _getOriginalZoneDefinition(index = this.currentZoneIndex) { const zoneName = this.zoneSequence[index]; if (!this.baseZoneDefinitions || !this.baseZoneDefinitions[zoneName]) { return { ideal_efficiency: 0.5, ideal_mobility: 0.5, ideal_resilience: 0.5, initial_resources: 1000, regen_rate: 1 }; } return this.baseZoneDefinitions[zoneName]; } _updateEffectiveResources() { const currentDef = this.getParams(); this.effectiveInitialResources = (currentDef.initial_resources || 0) * this.multiplier; this.effectiveRegenRate = (currentDef.regen_rate || 0) * this.multiplier; if (this.timeInStage === 0) { this.currentResources = this.effectiveInitialResources; } } getParams() { return this.currentZoneParams; } getZoneName() { return this.zoneSequence[this.currentZoneIndex]; } getTimeInStage() { return this.timeInStage; } getCurrentResources() { return this.currentResources; } getEffectiveInitialResources() { return this.effectiveInitialResources; } consumeResources(amount) { const consumed = Math.min(amount, this.currentResources); this.currentResources -= consumed; return consumed; } _maybeRunPhenotypeEnvironmentFeedback(averagePhenotype, turn) { if (!this.config.PEFF_ENABLED || turn === 0 || turn % this.config.PEFF_INTERVAL !== 0) { return; } if (!averagePhenotype || averagePhenotype.calculatedTurn < turn -1) { return; } if (averagePhenotype.calculatedTurn === -1 || (averagePhenotype.E === 0 && averagePhenotype.M === 0 && averagePhenotype.R === 0)) { return; } const currentIdeals = this.getParams(); const originalIdeals = this._getOriginalZoneDefinition(); let shifts = { E: 0, M: 0, R: 0 }; let changed = false; const traitKeys = [ { phenoKey: 'E', idealKey: 'ideal_efficiency' }, { phenoKey: 'M', idealKey: 'ideal_mobility' }, { phenoKey: 'R', idealKey: 'ideal_resilience' } ]; traitKeys.forEach(tk => { const popTrait = averagePhenotype[tk.phenoKey]; const currentIdeal = currentIdeals[tk.idealKey]; const originalIdeal = originalIdeals[tk.idealKey]; if (typeof popTrait !== 'number' || typeof currentIdeal !== 'number' || typeof originalIdeal !== 'number') { return; } const delta = popTrait - currentIdeal; let shiftAmount = 0; const peffMagnitude = this.dynamicSettings.peffIntensity; if (this.config.PEFF_MODE === "follow") { shiftAmount = delta * peffMagnitude; } else if (this.config.PEFF_MODE === "resist") { shiftAmount = -delta * peffMagnitude; } if (Math.abs(shiftAmount) < 0.0001) return; const potentialNewIdeal = currentIdeal + shiftAmount; const lowerBound = originalIdeal - this.config.PEFF_MAX_SHIFT; const upperBound = originalIdeal + this.config.PEFF_MAX_SHIFT; const clampedNewIdeal = Math.max(0.0, Math.min(1.0, Math.max(lowerBound, Math.min(upperBound, potentialNewIdeal)))); const actualShift = clampedNewIdeal - currentIdeal; if (Math.abs(actualShift) > 0.0001) { currentIdeals[tk.idealKey] = clampedNewIdeal; shifts[tk.phenoKey] = actualShift; changed = true; } }); if (changed) { const modeText = this.config.PEFF_MODE === "follow" ? "->" : "<-"; this.logger.log(turn, "Environment", `PEFF ${modeText} pop: E${shifts.E.toFixed(3)}, M${shifts.M.toFixed(3)}, R${shifts.R.toFixed(3)}`); } } update(averagePhenotype, turn) { this.timeInStage++; this._maybeRunPhenotypeEnvironmentFeedback(averagePhenotype, turn); const maxResources = this.effectiveInitialResources; const regen = this.effectiveRegenRate; if (this.currentResources < maxResources) { this.currentResources = Math.min(maxResources, this.currentResources + regen); } let disturbanceEvent = null; let successionOccurred = false; const effectiveSuccessionTimer = this.successionTimerBase / this.dynamicSettings.successionSpeedMultiplier; if (this.timeInStage >= effectiveSuccessionTimer) { successionOccurred = true; const oldZoneName = this.getZoneName(); this.currentZoneIndex = (this.currentZoneIndex + 1) % this.zoneSequence.length; this.timeInStage = 0; this.currentZoneParams = this._createMutableZoneParams(this.currentZoneIndex); const newZoneName = this.getZoneName(); this._updateEffectiveResources(); this.logger.log(turn, "Environment", `Succession: ${oldZoneName} -> ${newZoneName}`); } const effectiveDisturbanceProb = this.config.DEFAULT_DISTURBANCE_PROBABILITY * this.dynamicSettings.disturbanceRateMultiplier; if (!successionOccurred && this.timeInStage > 0 && Math.random() < effectiveDisturbanceProb) { const dT = this.config.DISTURBANCE_TYPES[Math.floor(Math.random() * this.config.DISTURBANCE_TYPES.length)]; if (dT === 'reset') { const oldZoneName = this.getZoneName(); this.currentZoneIndex = 0; this.timeInStage = 0; this.currentZoneParams = this._createMutableZoneParams(this.currentZoneIndex); const newZoneName = this.getZoneName(); this._updateEffectiveResources(); disturbanceEvent = { type: 'reset', from: oldZoneName, to: newZoneName }; this.logger.log(turn, "Environment", `Disturbance Reset -> ${newZoneName}`); } else if (dT === 'cull') { const cullStrength = Utils.randomInRange(this.config.DISTURBANCE_CULL_RANGE[0], this.config.DISTURBANCE_CULL_RANGE[1]); disturbanceEvent = { type: 'cull', strength: cullStrength }; this.logger.log(turn, "Disturbance", `Cull Trig (${(cullStrength * 100).toFixed(0)}%)`); } } return disturbanceEvent; } };
        class Organism { constructor(id, genomeInput, zone, parentId, turn, dependencies) { this.id = id; this.parentId = parentId; this.genome = ""; this.age = 0; this.zone = zone; this.alive = true; this.phenotype = {}; this.fitness = 0; this.lastAppliedSynergyModifier = 0; this.reasonForDeath = null; this.config = dependencies.config; this.utils = dependencies.utils; this.synergyEngine = dependencies.synergyEngine; this.mutationEngine = dependencies.mutationEngine; this.logger = dependencies.logger; if (typeof genomeInput !== 'string' || genomeInput.length < this.config.MIN_GENOME_LENGTH) { this.genome = this.config.INITIAL_GENOME; } else { this.genome = genomeInput; } try { this.calculatePhenotype(); } catch (phenoError) { this.phenotype = { metabolism: '?', efficiency: 0.1, mobility: 0.1, resilience: 0.1, lifespanMultiplier: 1.0 }; } } ageTick(environment, turn) { if (!this.alive) return false; this.age++; const efficiency = this.phenotype?.efficiency ?? 0; const consumptionModifier = 1.5 - efficiency; const resourcesNeeded = Math.max(0.01, this.config.BASE_CONSUMPTION_RATE * consumptionModifier); const consumed = environment.consumeResources(resourcesNeeded); if (consumed < resourcesNeeded && consumed <= 0.001) { this.die(`Starvation`, turn); return false; } const multiplier = this.phenotype?.lifespanMultiplier ?? 1.0; const effectiveLifespan = this.config.BASE_LIFESPAN * multiplier; if (this.age > effectiveLifespan) { this.die(`Old Age`, turn); return false; } return true; } calculatePhenotype() { this.phenotype = this.utils.interpretGenome(this.genome); } calculateFitness(envParams, turn) { if (!this.alive) { this.fitness = 0; return; } if (!this.phenotype || Object.keys(this.phenotype).length === 0) { this.calculatePhenotype(); } const ideal = envParams; const p = this.phenotype; const w = this.config.FITNESS_WEIGHTS; const eff = p?.efficiency ?? 0; const mob = p?.mobility ?? 0; const res = p?.resilience ?? 0; const dE = Math.abs(eff - ideal.ideal_efficiency); const dM = Math.abs(mob - ideal.ideal_mobility); const dR = Math.abs(res - ideal.ideal_resilience); let baseFitness = (w.efficiency * (1.0 - dE)) + (w.mobility * (1.0 - dM)) + (w.resilience * (1.0 - dR)); baseFitness = Math.max(0, Math.min(1, baseFitness)); let synergyModifier = 0; if (this.synergyEngine) { synergyModifier = this.synergyEngine.calculateModifier(this, this.phenotype, this.genome, baseFitness, turn); } this.fitness = Math.max(0, Math.min(1, baseFitness + synergyModifier)); } attemptSurvival(turn, deathThreshold) { if (!this.alive) return true; if (this.fitness < deathThreshold) { this.die(`Low Fitness`, turn); return false; } return true; } attemptReproduction(environment, turn, reproductionThreshold) { if (!this.alive) return null; if (this.fitness <= reproductionThreshold || this.age < this.config.MIN_REPRODUCTION_AGE || environment.getCurrentResources() < this.config.REPRODUCTION_RESOURCE_COST) { return null; } if (typeof this.genome !== 'string' || this.genome.length < this.config.MIN_GENOME_LENGTH) { return null; } environment.consumeResources(this.config.REPRODUCTION_RESOURCE_COST); const mutationResult = this.mutationEngine.applyMutation(this.genome, turn); const offspringGenome = mutationResult.newGenome; return { parentId: this.id, genome: offspringGenome, zone: this.zone, mutated: mutationResult.mutated }; } die(reason, turn) { if (!this.alive) return; this.alive = false; this.reasonForDeath = reason; let reasonKey = 'Unknown'; if (reason.startsWith('Old Age')) reasonKey = 'Old Age'; else if (reason.startsWith('Starvation')) reasonKey = 'Starvation'; else if (reason.startsWith('Low Fitness')) reasonKey = 'Low Fitness'; else if (reason.startsWith('Population Cap Cull')) reasonKey = 'Cap Cull'; else if (reason.startsWith('Disturbance Cull')) reasonKey = 'Disturbance Cull'; const genomeStr = typeof this.genome === 'string' ? this.genome : '?'; this.logger.log(turn, "Death", `${this.id}(${reason}). A${this.age},F${this.fitness.toFixed(3)},G[${genomeStr.slice(0,6)}]`, { reasonKey: reasonKey }); return { id: this.id, reasonKey: reasonKey, age: this.age, fitness: this.fitness, reason: reason }; } };
        const MythosEngine = { init(dependencies) { this.config = dependencies.config; this.utils = dependencies.utils; this.logger = dependencies.logger; this.dynamicSettings = dependencies.dynamicSettings; this.kanji = ['生','死','変','森','草','無','魂','水','火','土','光','影']; this.binarySnippets = ["01", "10", "00", "11", "0101", "1001", "0011", "1110"]; this.glyphs = ['≋','≒','◊','⚙️','⌬','❖','⁂','∿','҂','֎']; }, generateFragment(state, environment) { if (!this.config || !this.utils || !this.logger || !this.dynamicSettings) { return null; } let fragments = []; const focusTheme = this.utils.getRandomElement(['entropy', 'pop_change', 'fitness', 'resource', 'zone_info', 'lineage', 'raw_stat']); fragments.push(this._chooseContext(state, environment)); fragments.push(this._chooseObservation(focusTheme, state, environment)); fragments.push(this._chooseSymbolic(focusTheme, state, environment)); const fullFragment = fragments.filter(f => f).join(' '); return fullFragment || null; }, _chooseContext(state, environment) { const options = [ `T${state.turn}:`, `[${environment.getZoneName()}]`, state.lastDisturbance.type !== "None" ? `Post-${state.lastDisturbance.type.split('(')[0].trim()}:` : null, `Echo~${Math.floor(state.turn / 10) % 100}:`, `Src ${Utils.randomChar()}${state.turn % 10}:` ]; return this.utils.getRandomElement(options.filter(o => o !== null)); }, _chooseObservation(theme, state, environment) { const avgPheno = state.averagePhenotype; const popCount = state.organisms.length; const resPercent = environment.getEffectiveInitialResources() > 0 ? (environment.getCurrentResources() / environment.getEffectiveInitialResources()) * 100 : 0; switch (theme) { case 'entropy': if (!this.dynamicSettings?.genomeEntropyEnabled) return "Silence."; const entropy = state.genomeEntropy; if (entropy > 4.5) return this.utils.getRandomElement(["Voices diverge.", "Paths fracture.", "Chaos echoes."]); if (entropy < 1.5 && popCount > 5) return this.utils.getRandomElement(["Convergence.", "Song monotone.", "One pattern."]); return this.utils.getRandomElement(["Diversity shifts.", "Weave alters.", "Potential flows."]); case 'pop_change': if (popCount > config.POPULATION_CAP * 0.9) return this.utils.getRandomElement(["World teems.", "Edge capacity.", "Pressure."]); if (popCount < config.POPULATION_CAP * 0.1 && state.turn > 10) return this.utils.getRandomElement(["Few remain.", "Silence grows.", "Echoes fade."]); return this.utils.getRandomElement(["Life waxes/wanes.", "Numbers shift.", "Presence flickers."]); case 'fitness': const fit = avgPheno.F; if (fit > 0.8) return this.utils.getRandomElement(["Peak adaptation?", "Harmony?", "Fragile zenith."]); if (fit < 0.2 && popCount > 0) return this.utils.getRandomElement(["Struggle deepens.", "Mismatch pains.", "Env resists."]); return this.utils.getRandomElement(["Fitness flows.", "Adaptation drifts.", "Survival edge."]); case 'resource': if (resPercent < 10) return this.utils.getRandomElement(["Scarcity bites.", "Well dry.", "Hunger."]); if (resPercent > 90) return this.utils.getRandomElement(["Abundance.", "Overflow.", "Easy life."]); return this.utils.getRandomElement(["Sustenance changes.", "Flow ebbs.", "Cycle turns."]); case 'zone_info': const zoneName = environment.getZoneName(); const timeInZone = environment.getTimeInStage(); if (timeInZone < 5) return this.utils.getRandomElement([`New phase: ${zoneName}.`, `Ground shifts: ${zoneName}.`, `${zoneName} begins.`]); return this.utils.getRandomElement([`${zoneName} persists.`, `Time deepens in ${zoneName}.`, `${zoneName} era.`]); case 'lineage': if (state.organisms.length === 0) return "Ashes."; const randomOrg = this.utils.getRandomElement(state.organisms); if (!randomOrg) return "No signal."; const genomeSnippet = (randomOrg.genome || "?????").substring(0, 5); if (randomOrg.age > config.BASE_LIFESPAN * 1.5) return this.utils.getRandomElement([`${randomOrg.id} remembers.`, `Ancient ${genomeSnippet} persists.`, `Age defies for ${randomOrg.id}.`]); return this.utils.getRandomElement([`Trace :: ${genomeSnippet}...`, `From ${randomOrg.parentId || 'Source'}?`, `Vector ${randomOrg.id}.`]); case 'raw_stat': const options = [ `Pop:${popCount}`, `MaxAge:${state.maxAgeRecorded}`, `Deaths:${state.totalDeaths}`, `Born:${state.nextOrganismId}` ]; return this.utils.getRandomElement(options); default: return this.utils.getRandomElement(["Simulation breathes.", "Signals cross.", "State unclear."]); } }, _chooseSymbolic(theme, state, environment) { const entropyVal = state.dynamicSettings?.genomeEntropyEnabled ? `E:${state.genomeEntropy.toFixed(2)}` : 'E:X'; const fitnessVal = `F:${state.averagePhenotype.F.toFixed(3)}`; let genomeSample = "---"; if (state.organisms.length > 0) { const org = state.organisms[Math.floor(Math.random() * state.organisms.length)]; genomeSample = (org?.genome || "?????").substring(0, 4); } const options = [ entropyVal, fitnessVal, this.utils.getRandomElement(this.kanji), this.utils.getRandomElement(this.binarySnippets), this.utils.getRandomElement(this.glyphs), `::${genomeSample}` ]; return this.utils.getRandomElement(options); } };

        // --- SIMULATION MANAGER CLASS (Identical to 9.8 / 10.2html) ---
        class SimulationManager { constructor(config, dependencies, globalState) { this.config = config; this.utils = dependencies.utils; this.logger = dependencies.logger; this.uiManager = dependencies.uiManager; this.mutationEngine = dependencies.mutationEngine; this.synergyEngine = dependencies.synergyEngine; this.observer = dependencies.observer; this.mythosEngine = dependencies.mythosEngine; this.state = this.resetState(); this.environment = null; this.timerId = null; this.dynamicSettings = this.uiManager.getDynamicSettings(); this.lastStopReportData = null; this.globalState = globalState; this.activePresetForFlavor = null; }
            resetState() { return { turn: 0, organisms: [], nextOrganismId: 0, isRunning: false, lastDisturbance: { turn: 0, type: "None" }, averagePhenotype: { E: 0, M: 0, R: 0, L: 1.0, F: 0.0, calculatedTurn: -1 }, maxAgeRecorded: 0, totalMutations: 0, totalCapCulls: 0, totalDisturbanceCulls: 0, totalStarvationDeaths: 0, totalOldAgeDeaths: 0, totalLowFitnessDeaths: 0, totalUnknownDeaths: 0, totalDeaths: 0, rawPopHistory: [], rawFitnessHistory: [], smoothedPopHistory: [], smoothedFitnessHistory: [], totalBornHistory: [], totalMutationsHistory: [], totalDeathsHistory: [], organismRegistry: new Map(), genomeEntropy: 0, activeStoryId: null, triggeredFlavorEvents: new Set(), entropyHistory: [], dominantFocusHistory: [], previousTickEntropy: 0, entropyDelta30Tick: 0 }; }
            initialize() { this.state = this.resetState(); if (this.globalState.stagedPresetId) { if (this.globalState.settingsModifiedSinceLoad) { this.state.activeStoryId = `modified_${this.globalState.stagedPresetId}`; } else { this.state.activeStoryId = this.globalState.stagedPresetId; } } else { this.state.activeStoryId = null; } this.globalState.stagedPresetId = null; this.globalState.settingsModifiedSinceLoad = false; this.uiManager.resetStoryLoadButtons(); this.observer.snapshot = this.observer.resetSnapshot(); this.logger.clearLogs(); this.logger.setTurn(0); this.dynamicSettings = this.uiManager.getDynamicSettings(); this.logger.log(0, "System", `Init Sim v10.2`); // Updated version log
                let storyTitle = 'Manual Settings'; let logMessage = 'Manual Simulation Started.'; let activePresetForFlavor = null; if (this.state.activeStoryId) { if (this.state.activeStoryId.startsWith('modified_')) { const baseId = this.state.activeStoryId.substring(9); const story = storyPresets.find(s => s.id === baseId); if (story) { storyTitle = `Modified (${story.title})`; logMessage = `Modified Story Started: ${story.title}`; activePresetForFlavor = story; } else { storyTitle = `Modified (${baseId})`; logMessage = `Modified Story Started: ${baseId}`; } } else { const story = storyPresets.find(s => s.id === this.state.activeStoryId); if (story) { storyTitle = story.title; logMessage = `Story Started: ${story.title}`; activePresetForFlavor = story; } else { storyTitle = this.state.activeStoryId; logMessage = `Story Started: ${this.state.activeStoryId}`; } } } this.logger.log(0, "System", logMessage); this.uiManager.setText(this.uiManager.dom['running-story-label'], `Currently running: ${storyTitle}`); this.activePresetForFlavor = activePresetForFlavor; this.lastStopReportData = null; this.uiManager.hideSaveReportButton(); const engineDependencies = { config: this.config, utils: this.utils, logger: this.logger, dynamicSettings: this.dynamicSettings }; this.mutationEngine.init(engineDependencies); this.synergyEngine.init({ config: this.config, logger: this.logger }); this.observer.init(engineDependencies); this.mythosEngine.init({ config: this.config, utils: this.utils, logger: this.logger, dynamicSettings: this.dynamicSettings }); try { this.environment = new Environment( this.config.ZONE_SEQUENCE, this.config.ZONE_DEFINITIONS_BASE, this.config.SUCCESSION_TIMER_BASE, this.dynamicSettings.resourceMultiplier, { config: this.config, logger: this.logger, dynamicSettings: this.dynamicSettings } ); } catch (envError) { this.logger.log(0, "Error", `Env fail: ${envError.message}`); throw envError; } const initialZoneName = this.environment.getZoneName(); const initialEnvParams = this.environment.getParams(); this.logger.log(0, "Environment", `Init Zone: ${initialZoneName}.`); for (let i = 0; i < this.config.INITIAL_POPULATION; i++) { this._createOrganism({ genome: this.config.INITIAL_GENOME, zone: initialZoneName, parentId: null }, 0); } this._calculateAndStoreAveragePhenotype(); this.state.organisms.forEach(org => { try { org.calculateFitness(initialEnvParams, 0); } catch (fitError) { this.logger.log(0, "Warning", `Initial fitness calc failed for ${org.id}`); } }); this._calculateAndStoreAveragePhenotype(); if (this.dynamicSettings.genomeEntropyEnabled) { this.state.genomeEntropy = this.utils.calculateGenomeEntropy(this.state.organisms); } else { this.state.genomeEntropy = 0;} this.state.previousTickEntropy = this.state.genomeEntropy; this.state.entropyHistory = [this.state.genomeEntropy]; this.state.entropyDelta30Tick = 0; const focusInfo = this.uiManager.getDominantFocusInfo(this.state.averagePhenotype, initialEnvParams); this.state.dominantFocusHistory = [{turn: 0, focus: focusInfo.text}]; this.observer.updateSnapshot(this.state, this.environment, this.uiManager); this.uiManager.update(this.state, this.environment, this.dynamicSettings, null); this.uiManager.updateMajorLogDisplay(this.logger.getLogs().major); console.log("SimMgr Init OK."); }
            _getNextOrganismId() { const id = `ORG_${this.state.nextOrganismId.toString().padStart(6, '0')}`; this.state.nextOrganismId++; return id; }
            _createOrganism(birthData, turn) { const newId = this._getNextOrganismId(); const dependencies = { config: this.config, utils: this.utils, synergyEngine: this.synergyEngine, mutationEngine: this.mutationEngine, logger: this.logger }; try { const newOrg = new Organism(newId, birthData.genome, birthData.zone, birthData.parentId, turn, dependencies); const currentEnvParams = this.environment.getParams(); try { newOrg.calculateFitness(currentEnvParams, turn); } catch (newbornFitError) { this.logger.log(turn, "Warning", `Fitness calc failed for newborn ${newOrg.id}`); } this.state.organisms.push(newOrg); const registryEntry = { id: newOrg.id, parentId: newOrg.parentId, genome: newOrg.genome, birthTurn: turn, deathTurn: null, ageAtDeath: null, reasonForDeath: null, fitnessAtDeath: null }; this.state.organismRegistry.set(newOrg.id, registryEntry); if (turn > 0) { const pheno = newOrg.phenotype; const mult = pheno?.lifespanMultiplier ?? 1.0; const genomeStr = typeof newOrg.genome === 'string' ? newOrg.genome : '?'; this.logger.log(turn, "Birth", `${newOrg.parentId || 'Init'}->${newOrg.id}`, { mutated: birthData.mutated ?? false }); } return newOrg; } catch (error) { this.logger.log(turn, "Error", `Failed to create organism: ${error.message}`); return null; } }
            _processDeath(deathData, turn) { if (!deathData) return 0; this.state.totalDeaths++; switch (deathData.reasonKey) { case 'Old Age': this.state.totalOldAgeDeaths++; break; case 'Starvation': this.state.totalStarvationDeaths++; break; case 'Low Fitness': this.state.totalLowFitnessDeaths++; break; case 'Cap Cull': this.state.totalCapCulls++; break; case 'Disturbance Cull': this.state.totalDisturbanceCulls++; break; default: this.state.totalUnknownDeaths++; break; } if (deathData.age > this.state.maxAgeRecorded) { this.state.maxAgeRecorded = deathData.age; } const registryEntry = this.state.organismRegistry.get(deathData.id); if (registryEntry) { registryEntry.deathTurn = turn; registryEntry.ageAtDeath = deathData.age; registryEntry.reasonForDeath = deathData.reason; registryEntry.fitnessAtDeath = deathData.fitness; } return 1; }
            _calculateAndStoreAveragePhenotype() { const popCount = this.state.organisms.length; if (popCount === 0) { this.state.averagePhenotype = { E: 0, M: 0, R: 0, L: 1.0, F: 0.0, calculatedTurn: this.state.turn }; return; } let sumE = 0, sumM = 0, sumR = 0, sumL = 0, sumF = 0; for(const org of this.state.organisms) { const pheno = org.phenotype; sumE += (pheno?.efficiency || 0); sumM += (pheno?.mobility || 0); sumR += (pheno?.resilience || 0); sumL += (pheno?.lifespanMultiplier || 1.0); sumF += (org.fitness || 0); } this.state.averagePhenotype = { E: sumE / popCount, M: sumM / popCount, R: sumR / popCount, L: sumL / popCount, F: sumF / popCount, calculatedTurn: this.state.turn }; }
            updateDynamicSettings() { this.dynamicSettings = this.uiManager.getDynamicSettings(); }
            tick() { if (!this.state.isRunning) return; try { this.state.turn++; const turn = this.state.turn; this.logger.setTurn(turn); this.state.previousTickEntropy = this.state.genomeEntropy; this._calculateAndStoreAveragePhenotype(); const currentAvgPhenotype = this.state.averagePhenotype; const disturbanceEvent = this.environment.update(currentAvgPhenotype, turn); const currentEnvParams = this.environment.getParams(); let newBirthsData = []; let deathsData = []; const currentDeathThreshold = this.dynamicSettings.deathThreshold; const currentReproThreshold = this.dynamicSettings.reproductionThreshold; let tickMutationCount = 0; let tickBirthCount = 0; let tickDeathCount = 0; for (let i = this.state.organisms.length - 1; i >= 0; i--) { const org = this.state.organisms[i]; if (!org || !org.alive) continue; try { let diedThisTick = false; if (!org.ageTick(this.environment, turn)) { deathsData.push(org.die(org.reasonForDeath || '?', turn)); diedThisTick = true; } if (diedThisTick) continue; org.calculateFitness(currentEnvParams, turn); if (!org.attemptSurvival(turn, currentDeathThreshold)) { deathsData.push(org.die(org.reasonForDeath || '?', turn)); diedThisTick = true; } if (diedThisTick) continue; const offspringData = org.attemptReproduction(this.environment, turn, currentReproThreshold); if (offspringData) { newBirthsData.push(offspringData); if (offspringData.mutated) { this.state.totalMutations++; tickMutationCount++; } } } catch (orgError) { this.logger.log(turn, "Error", `Error processing organism ${org?.id}: ${orgError.message}`); } } this.state.organisms = this.state.organisms.filter(org => org.alive); deathsData.forEach(dData => { tickDeathCount += this._processDeath(dData, turn); }); newBirthsData.forEach(bData => { if (this._createOrganism(bData, turn)) { tickBirthCount++; } }); let hadDisturbanceCull = false; let disturbanceCullCountActual = 0; if (disturbanceEvent?.type === 'cull') { this.state.lastDisturbance = { turn: turn, type: `Cull (${(disturbanceEvent.strength * 100).toFixed(0)}%)` }; const popBefore = this.state.organisms.length; if (popBefore > 0) { const numberToKeep = Math.floor(popBefore * (1.0 - disturbanceEvent.strength)); if (popBefore - numberToKeep > 0) { this.state.organisms.sort(() => 0.5 - Math.random()); const culledOrganisms = this.state.organisms.slice(numberToKeep); const cullReason = `Disturbance Cull`; culledOrganisms.forEach(org => { if (org.alive) { const deathData = org.die(cullReason, turn); tickDeathCount += this._processDeath(deathData, turn); disturbanceCullCountActual++; } }); this.state.organisms = this.state.organisms.slice(0, numberToKeep); hadDisturbanceCull = true; } } } else if (disturbanceEvent?.type === 'reset') { this.state.lastDisturbance = { turn: turn, type: `Reset to ${disturbanceEvent.to}` }; } let capCullCountActual = 0; if (this.state.organisms.length > this.config.POPULATION_CAP) { const cullCount = this.state.organisms.length - this.config.POPULATION_CAP; this.state.organisms.sort((a, b) => (a.fitness ?? 0) - (b.fitness ?? 0)); const culledByCap = this.state.organisms.slice(0, cullCount); const capCullReason = `Cap Cull`; culledByCap.forEach(org => { if (org.alive) { const deathData = org.die(capCullReason, turn); tickDeathCount += this._processDeath(deathData, turn); capCullCountActual++; } }); this.state.organisms = this.state.organisms.slice(cullCount); }
                 this._calculateAndStoreAveragePhenotype(); if (this.dynamicSettings.genomeEntropyEnabled) { this.state.genomeEntropy = this.utils.calculateGenomeEntropy(this.state.organisms); } else { this.state.genomeEntropy = 0; } this.state.entropyHistory.push(this.state.genomeEntropy); if (this.state.entropyHistory.length > config.MYTHO_BAR_HISTORY_LENGTH) { this.state.entropyHistory.shift(); } if (this.state.entropyHistory.length >= config.MYTHO_BAR_HISTORY_LENGTH) { const oldEntropy = this.state.entropyHistory[0]; this.state.entropyDelta30Tick = this.state.genomeEntropy - oldEntropy; } else { this.state.entropyDelta30Tick = 0; } const focusInfo = this.uiManager.getDominantFocusInfo(this.state.averagePhenotype, currentEnvParams); this.state.dominantFocusHistory.push({turn: turn, focus: focusInfo.text}); if (this.state.dominantFocusHistory.length > config.MYTHO_BAR_TRAIT_LOCK_TURNS + 1) { this.state.dominantFocusHistory.shift(); } const currentPopCount = this.state.organisms.length; const currentAvgFitness = this.state.averagePhenotype.F; this.state.rawPopHistory.push(currentPopCount); this.state.rawFitnessHistory.push(currentAvgFitness); const maxRawHistory = this.config.GRAPH_SMOOTHING_WINDOW + 5; if (this.state.rawPopHistory.length > maxRawHistory) { this.state.rawPopHistory.shift(); this.state.rawFitnessHistory.shift(); } let smoothedPop = 0; let smoothedFit = 0; const smoothWindow = Math.min(this.state.rawPopHistory.length, this.config.GRAPH_SMOOTHING_WINDOW); if (smoothWindow > 0) { const popSlice = this.state.rawPopHistory.slice(-smoothWindow); const fitSlice = this.state.rawFitnessHistory.slice(-smoothWindow); smoothedPop = popSlice.reduce((a, b) => a + b, 0) / smoothWindow; smoothedFit = fitSlice.reduce((a, b) => a + b, 0) / smoothWindow; } this.state.smoothedPopHistory.push(smoothedPop); this.state.smoothedFitnessHistory.push(smoothedFit); if (this.state.smoothedPopHistory.length > this.config.GRAPH_WINDOW_SIZE) { this.state.smoothedPopHistory.shift(); this.state.smoothedFitnessHistory.shift(); } this.state.totalBornHistory.push(this.state.nextOrganismId); this.state.totalMutationsHistory.push(this.state.totalMutations); this.state.totalDeathsHistory.push(this.state.totalDeaths); if (this.state.totalBornHistory.length > this.config.GRAPH_WINDOW_SIZE) { this.state.totalBornHistory.shift(); this.state.totalMutationsHistory.shift(); this.state.totalDeathsHistory.shift(); } if (turn > 0 && turn % this.config.SPOTLIGHT_AUTO_UPDATE_INTERVAL === 0) { if (this.uiManager.dom['spotlight-output']?.classList.contains('lineage-visible')) { this.spotlightFittestOrganism(); } } this.observer.maybeGenerateReport(this.state, this.environment, this.uiManager); let triggerMythos = false; if (this.config.MYTHOS_ENABLED && this.state.isRunning && this.state.turn > 0) { if (this.state.turn % this.config.MYTHOS_INTERVAL === 0) { triggerMythos = true; } else if (Math.random() < this.config.MYTHOS_BURST_PROBABILITY) { triggerMythos = true; } } if (triggerMythos) { try { const fragmentText = this.mythosEngine.generateFragment(this.state, this.environment); if (fragmentText) { this.logger.log(turn, "Mythos", fragmentText); this.uiManager.displayFloatingMythos(fragmentText); } } catch (mythosError) { this.logger.log(turn, "Error", `Mythos fail: ${mythosError.message}`); } }
                 const isExtinct = currentPopCount === 0 && turn > 0;
                 this._checkAndTriggerFlavorText(turn, { extinction: isExtinct, disturbance: hadDisturbanceCull || disturbanceEvent?.type === 'reset', mutation: tickMutationCount > 0 });
                 this.uiManager.update(this.state, this.environment, this.dynamicSettings, { birthCount: tickBirthCount, deathCount: tickDeathCount, mutationCount: tickMutationCount, disturbanceType: disturbanceEvent?.type, isExtinct: isExtinct, avgFitness: currentAvgFitness, entropyDelta30Tick: this.state.entropyDelta30Tick });
                 const totalDeathsThisTickActual = tickDeathCount; this.logger.log(turn, "Summary", `P:${currentPopCount}(B:${tickBirthCount},D:${totalDeathsThisTickActual},M:${tickMutationCount}) R:${this.environment.getCurrentResources().toFixed(1)}`); if (isExtinct) { this.logger.log(turn, "System", "Extinction. Stop."); this.stop(); return; } if (this.state.isRunning) { this.timerId = setTimeout(() => this.tick(), this.config.TICK_INTERVAL_MS); } } catch (error) { this.logger.log(this.state.turn, "Error", `Tick Crash: ${error.message}`); console.error("Tick Error:", error.stack || error); this.stop(); this.uiManager.update(this.state, this.environment, this.dynamicSettings, null); } }
            startSimulation() { if (this.state.isRunning) { console.warn("Simulation already running."); return; } console.log("Start Simulation button clicked."); this.uiManager.hideSaveReportButton(); this.lastStopReportData = null; try { this.initialize(); } catch (initError) { this.logger.log(0, "Error", `Initialization Failed: ${initError.message}`); this.globalState.stagedPresetId = null; this.globalState.settingsModifiedSinceLoad = false; this.state.isRunning = false; // Ensure state reflects failure
                    this.uiManager.update(this.state, this.environment, this.dynamicSettings, null); // Update UI to stopped state
                    return; // Prevent timer start
                } this.state.isRunning = true; this.uiManager.update(this.state, this.environment, this.dynamicSettings, null); if (this.state.organisms.length > 0) { this.timerId = setTimeout(() => this.tick(), this.config.TICK_INTERVAL_MS); } else { // Handle immediate extinction case if initial pop fails somehow
                    this.logger.log(0, "Warning", "Initial population empty or failed, stopping immediately."); this.stop(); } }
            _checkAndTriggerFlavorText(turn, eventFlags) { const activePreset = this.activePresetForFlavor; if (!activePreset || !activePreset.flavorText) { return; } const flavorTexts = activePreset.flavorText; const triggers = config.STORY_FLAVOR_TRIGGERS; let triggered = false; const potentialTriggers = []; potentialTriggers.push(`turn${turn}`); if (eventFlags.extinction) potentialTriggers.push('extinction'); if (eventFlags.disturbance) potentialTriggers.push('disturbance'); if (eventFlags.mutation) potentialTriggers.push('mutation'); if (this.dynamicSettings.genomeEntropyEnabled) { if (this.state.genomeEntropy >= triggers.peakEntropy) potentialTriggers.push('peakEntropy'); if (this.state.genomeEntropy <= triggers.lowEntropy) potentialTriggers.push('lowEntropy'); if (this.state.genomeEntropy >= triggers.highEntropy) potentialTriggers.push('highEntropy'); } potentialTriggers.forEach(triggerKey => { if (flavorTexts[triggerKey] && !this.state.triggeredFlavorEvents.has(triggerKey)) { const textOptions = flavorTexts[triggerKey]; if (textOptions && textOptions.length > 0) { const chosenText = this.utils.getRandomElement(textOptions); this.logger.log(turn, "Story", chosenText); this.state.triggeredFlavorEvents.add(triggerKey); triggered = true; } } }); }
            stop() { if (!this.state.isRunning && this.timerId === null) { return; } const wasRunning = this.state.isRunning; this.state.isRunning = false; if (this.timerId) { clearTimeout(this.timerId); this.timerId = null; } const finalTurnForLog = this.state.turn; if (wasRunning) { this.logger.log(finalTurnForLog, "System", "Sim stopped."); } if (wasRunning || this.state.turn > 0) { const finalState = this.state; const finalEnv = this.environment; const finalSettings = this.dynamicSettings; const recentMajorLogs = this.logger.getLogs().major.slice(-15); let storyInfo = "Manual"; let baseStoryId = null; if (finalState.activeStoryId) { if (finalState.activeStoryId.startsWith('modified_')) { baseStoryId = finalState.activeStoryId.substring(9); const story = storyPresets.find(s => s.id === baseStoryId); storyInfo = `Modified (${story ? story.title : baseStoryId})`; } else { baseStoryId = finalState.activeStoryId; const story = storyPresets.find(s => s.id === baseStoryId); storyInfo = story ? story.title : baseStoryId; } } this.lastStopReportData = { stopReason: finalState.organisms.length === 0 && finalState.turn > 0 ? "Extinction" : "Manual Stop", finalTurn: finalState.turn, timestamp: new Date().toISOString(), population: finalState.organisms.length, populationCap: this.config.POPULATION_CAP, avgFitness: finalState.averagePhenotype?.F ?? 0, // Added null check
                    avgGenomeLength: finalState.organisms.length > 0 ? finalState.organisms.reduce((sum, org) => sum + (org?.genome?.length || 0), 0) / finalState.organisms.length : 0, avgPhenotype: { ...finalState.averagePhenotype }, genomeEntropy: finalState.genomeEntropy, zone: finalEnv?.getZoneName() || 'N/A', timeInZone: finalEnv?.getTimeInStage() || 0, zoneDuration: finalEnv ? (this.config.SUCCESSION_TIMER_BASE / finalSettings.successionSpeedMultiplier).toFixed(0) : 'N/A', idealTraits: finalEnv?.getParams() ? { ...finalEnv.getParams() } : {}, resources: finalEnv?.getCurrentResources() || 0, maxResources: finalEnv?.getEffectiveInitialResources() || 0, totalBorn: finalState.nextOrganismId, totalMutations: finalState.totalMutations, maxAgeRecorded: finalState.maxAgeRecorded, totalDeaths: finalState.totalDeaths, totalOldAgeDeaths: finalState.totalOldAgeDeaths, totalStarvationDeaths: finalState.totalStarvationDeaths, totalLowFitnessDeaths: finalState.totalLowFitnessDeaths, totalCapCulls: finalState.totalCapCulls, totalDisturbanceCulls: finalState.totalDisturbanceCulls, settings: { ...finalSettings }, activeStory: storyInfo, recentMajorLogs: recentMajorLogs }; this.uiManager.showSaveReportButton(); } else { this.lastStopReportData = null; this.uiManager.hideSaveReportButton(); } this.activePresetForFlavor = null; this.state.activeStoryId = null; this.state.triggeredFlavorEvents.clear(); this.globalState.stagedPresetId = null; this.globalState.settingsModifiedSinceLoad = false; this.uiManager.resetStoryLoadButtons(); if (this.uiManager) { this.updateDynamicSettings(); this.uiManager.update(this.state, this.environment, this.dynamicSettings, null); this.uiManager.updateMajorLogDisplay(this.logger.getLogs().major); } console.log("SimMgr Stop complete."); }
            spotlightFittestOrganism() { if (!this.uiManager) return; const livingOrganisms = this.state.organisms.filter(org => org.alive); if (livingOrganisms.length === 0) { this.uiManager.updateSpotlightTarget("None (Zero Pop)"); this.uiManager.displaySpotlightLineage(""); return; } let fittestOrganism = livingOrganisms.reduce((fittest, current) => { return (current.fitness > (fittest?.fitness ?? -1)) ? current : fittest; }, null); if (!fittestOrganism) { this.uiManager.updateSpotlightTarget("None (Error finding fittest)"); this.uiManager.displaySpotlightLineage(""); return; } const pheno = fittestOrganism.phenotype; const lifeMult = pheno?.lifespanMultiplier?.toFixed(2) ?? '?'; this.uiManager.updateSpotlightTarget(`${fittestOrganism.id} (F:${fittestOrganism.fitness.toFixed(3)}, A:${fittestOrganism.age}, L:${lifeMult}x)`); const lineage = []; let currentId = fittestOrganism.id; let safetyCounter = 0; const maxTraceDepth = this.state.nextOrganismId + 10; while (currentId != null && safetyCounter < maxTraceDepth) { const entry = this.state.organismRegistry.get(currentId); if (!entry) { lineage.push({ id: currentId, error: "Reg Miss" }); break; } lineage.push({ id: entry.id, parentId: entry.parentId, birthTurn: entry.birthTurn, deathTurn: entry.deathTurn, ageAtDeath: entry.ageAtDeath, genome: entry.genome, reasonForDeath: entry.reasonForDeath }); currentId = entry.parentId; safetyCounter++; } if (safetyCounter >= maxTraceDepth) { this.uiManager.displaySpotlightLineage(`ERR: Trace Depth Limit (${maxTraceDepth}) Reached`); return; } lineage.reverse(); let outputHtml = ""; const escapeHtml = (unsafe) => { if (unsafe === null || typeof unsafe === 'undefined') return ""; return String(unsafe).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }; lineage.forEach((orgData, index) => { const indent = "&nbsp;".repeat(index * 2); const genomeSnippet = escapeHtml((orgData.genome || "?").substring(0, 25)) + ((orgData.genome?.length || 0) > 25 ? "..." : ""); let statusHtml = ""; if (orgData.error) { statusHtml = ` <span class="lineage-error">ERR:${escapeHtml(orgData.error)}</span>`; } else if (orgData.deathTurn !== null) { const reason = escapeHtml(orgData.reasonForDeath || '?'); statusHtml = ` <span class="lineage-status-dead">(D T:${orgData.deathTurn}, A:${orgData.ageAtDeath ?? '?'})</span> R:<span class="lineage-death-reason">${reason}</span>`; } else { if (orgData.id === fittestOrganism.id && fittestOrganism.alive) { statusHtml = ` <span class="lineage-status-alive">(Alive)</span>`; } else { // Should ideally not happen for the target, but good fallback
                        statusHtml = ` <span class="lineage-status-alive">(Assumed Alive)</span>`; } } outputHtml += `${indent}<span class="lineage-turn">T:${orgData.birthTurn ?? '?'}</span> <span class="lineage-id">${orgData.id}</span> [<span class="lineage-genome">${genomeSnippet}</span>]${statusHtml}\n`; }); this.uiManager.displaySpotlightLineage(outputHtml || "Lineage trace fail."); }
            generateAndDownloadReport() { if (!this.lastStopReportData) { console.warn("No report data to save."); this.logger.log(this.state.turn || 0, "Warning", "Save report clicked, no data."); return; } const data = this.lastStopReportData; let reportString = `--- Terrarium Zero: End Report ---\nTimestamp: ${data.timestamp}\nStop Reason: ${data.stopReason}\nFinal Turn: ${data.finalTurn}\nActive Story: ${data.activeStory}\n\n--- Final State ---\nPopulation: ${data.population}/${data.populationCap}\nAvg Fitness: ${data.avgFitness?.toFixed(3) ?? 'N/A'}\nAvg Genome Len: ${data.avgGenomeLength?.toFixed(2) ?? 'N/A'}\nAvg Phenotype (E/M/R): E:${data.avgPhenotype?.E?.toFixed(2) ?? 'N/A'} M:${data.avgPhenotype?.M?.toFixed(2) ?? 'N/A'} R:${data.avgPhenotype?.R?.toFixed(2) ?? 'N/A'}\nAvg Lifespan Mult: ${data.avgPhenotype?.L?.toFixed(2) ?? 'N/A'}x\nGenome Entropy: ${data.settings.genomeEntropyEnabled ? (data.genomeEntropy?.toFixed(3) ?? 'N/A') : 'Off'}\n\n--- Environment ---\nZone: ${data.zone}\nTime in Zone: ${data.timeInZone}/${data.zoneDuration} turns\nIdeal Traits (E/M/R): E:${data.idealTraits?.ideal_efficiency?.toFixed(2) ?? 'N/A'} M:${data.idealTraits?.ideal_mobility?.toFixed(2) ?? 'N/A'} R:${data.idealTraits?.ideal_resilience?.toFixed(2) ?? 'N/A'}\nResources: ${data.resources?.toFixed(1)}/${data.maxResources?.toFixed(1)}\n\n--- Lifetime Stats ---\nTotal Born: ${data.totalBorn}\nTotal Mutations: ${data.totalMutations}\nMax Age Recorded: ${data.maxAgeRecorded} turns\nTotal Deaths (All): ${data.totalDeaths}\n  Old Age: ${data.totalOldAgeDeaths}\n  Starvation: ${data.totalStarvationDeaths}\n  Low Fitness: ${data.totalLowFitnessDeaths}\n  Cap Culls: ${data.totalCapCulls}\n  Disturbance Culls: ${data.totalDisturbanceCulls}\n\n--- Tuning Settings at Stop ---\nResource Multiplier: ${(data.settings.resourceMultiplier * 100).toFixed(0)}%\nMutation Rate: ${(data.settings.mutationRate * 100).toFixed(0)}%\nSuccession Speed: ${data.settings.successionSpeedMultiplier.toFixed(1)}x\nDisturbance Rate: ${data.settings.disturbanceRateMultiplier.toFixed(1)}x\nPEFF Intensity: ${data.settings.peffIntensity.toFixed(3)}\nFitness Curve: ${data.settings.fitnessCurve}\nObserver Mode: ${data.settings.observerMode}\nGenome Entropy Tracker: ${data.settings.genomeEntropyEnabled ? 'On' : 'Off'}\n\n--- Recent Major Events (Last ${data.recentMajorLogs.length}) ---\n`; data.recentMajorLogs.forEach(log => { reportString += `[${log.turn}] ${log.type}: ${log.message}\n`; }); reportString += `--- End of Report ---`; try { const blob = new Blob([reportString], { type: 'text/plain;charset=utf-8' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; const filename = `terrarium_report_${data.activeStory.replace(/[\s()]/g, '_').replace(/__+/g, '_')}_T${data.finalTurn}_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.txt`; link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); this.logger.log(this.state.turn || data.finalTurn, "System", `Generated report: ${filename}`); } catch (e) { console.error("Download err:", e); this.logger.log(this.state.turn || data.finalTurn, "Error", `Report dl failed: ${e.message}`); console.log("--- REPORT DATA ---\n", reportString); alert("Report DL fail. Data in console."); } }
        }

        // --- MAIN EXECUTION (Includes Story Mode +/- Toggle Logic) ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing Terrarium Zero v10.2..."); // Updated version
            const globalState = { stagedPresetId: null, settingsModifiedSinceLoad: false };
            const uiManager = new UIManager();
            const logger = new Logger(uiManager);
            const simulationManager = new SimulationManager(config, {
                utils: Utils,
                logger: logger,
                uiManager: uiManager,
                mutationEngine: MutationEngine,
                synergyEngine: SynergyEngine,
                observer: Observer,
                mythosEngine: MythosEngine
            }, globalState);

            // --- Event Listeners (Mostly Unchanged) ---
            if (uiManager.dom.startButton) { uiManager.dom.startButton.addEventListener('click', () => { simulationManager.startSimulation(); }); }
            if (uiManager.dom.stopButton) { uiManager.dom.stopButton.addEventListener('click', () => simulationManager.stop()); }
            if (uiManager.dom.spotlightButton) { uiManager.dom.spotlightButton.addEventListener('click', () => simulationManager.spotlightFittestOrganism()); }
            if (uiManager.dom.toggleLineageButton) { uiManager.dom.toggleLineageButton.addEventListener('click', () => uiManager.toggleLineageDisplay()); }
            if (uiManager.dom.saveReportButton) { uiManager.dom.saveReportButton.addEventListener('click', () => simulationManager.generateAndDownloadReport()); }
            if (uiManager.dom['story-list']) {
                uiManager.dom['story-list'].addEventListener('click', (event) => {
                    if (event.target && event.target.classList.contains('story-load-button')) {
                        const presetId = event.target.getAttribute('data-preset-id');
                        if (presetId) {
                            if (uiManager.applyPresetToControls(presetId)) {
                                globalState.stagedPresetId = presetId;
                                globalState.settingsModifiedSinceLoad = false;
                                console.log(`Staged preset: ${presetId}`);
                            }
                        }
                    }
                });
            }

            // --- Tuning Controls Modification Listener (Unchanged) ---
             const tuningControlsContainer = uiManager.dom['tuning-controls'];
             if (tuningControlsContainer) {
                 const controlIdsToMonitor = [ 'resourceMultiplierSlider', 'mutationRateSlider', 'successionSpeedSlider', 'disturbanceRateSlider', 'peffIntensitySlider', 'fitnessCurveSelect', 'observerModeSelect', 'genomeEntropyToggle' ];
                 controlIdsToMonitor.forEach(id => {
                     const controlElement = uiManager.dom[id];
                     if (controlElement) {
                         const eventType = (controlElement.type === 'checkbox' || controlElement.tagName === 'SELECT') ? 'change' : 'input';
                         controlElement.addEventListener(eventType, () => {
                             if (globalState.stagedPresetId) {
                                 globalState.settingsModifiedSinceLoad = true;
                                 console.log(`Settings modified after loading preset ${globalState.stagedPresetId}`);
                                 // Optionally reset the running story label or indicator here if desired
                                 const runningLabel = uiManager.dom['running-story-label'];
                                 if(runningLabel && globalState.stagedPresetId){
                                      const story = storyPresets.find(s => s.id === globalState.stagedPresetId);
                                      runningLabel.innerHTML = `Currently running: Modified (${story ? story.title : globalState.stagedPresetId})`;
                                 }
                             }
                         });
                     }
                 });
             }

            // --- Slider Display Updates (Unchanged) ---
            const sliders = [ {slider: 'resourceMultiplierSlider', value: 'resourceMultiplierValue', suffix: '%'}, {slider: 'mutationRateSlider', value: 'mutationRateValue', suffix: '%'}, {slider: 'successionSpeedSlider', value: 'successionSpeedValue', suffix: 'x', fixed: 1}, {slider: 'disturbanceRateSlider', value: 'disturbanceRateValue', suffix: 'x', fixed: 1}, {slider: 'peffIntensitySlider', value: 'peffIntensityValue', suffix: '', fixed: 3} ];
            sliders.forEach(s => {
                if (uiManager.dom[s.slider]) {
                    uiManager.dom[s.slider].addEventListener('input', () => {
                        uiManager.updateSliderDisplay(s.slider, s.value, s.suffix, 1, s.fixed);
                    });
                }
            });

            // --- NEW: Story Mode Details Toggle +/- Icon Logic ---
            const storyDetails = document.querySelector('#story-mode-panel details');
            const storyToggleIcon = document.querySelector('#story-mode-panel summary .toggle-icon');
            if (storyDetails && storyToggleIcon) {
                storyDetails.addEventListener('toggle', () => {
                    storyToggleIcon.textContent = storyDetails.open ? '[-]' : '[+]';
                });
                // Initial check in case it starts closed (though default is open)
                storyToggleIcon.textContent = storyDetails.open ? '[-]' : '[+]';
            }
            // --- End New Toggle Logic ---


            // --- Initial UI State Setup (Unchanged) ---
            uiManager.updateAllSliderDisplays();
            uiManager.setDisabled(uiManager.dom.stopButton, true);
            uiManager.hideSaveReportButton();
            if(uiManager.dom.fitnessCurveSelect) uiManager.dom.fitnessCurveSelect.value = 'balanced';
            if(uiManager.dom.observerModeSelect) uiManager.dom.observerModeSelect.value = 'reflective';
            if(uiManager.dom.genomeEntropyToggle) uiManager.dom.genomeEntropyToggle.checked = false;

            console.log("Terrarium Zero v10.2 Ready."); // Updated version
        });

    </script>

</body>
</html>
```

**Summary of Changes Made:**

1.  **Patch Note:** Added `<!-- Patch: v10.2 - Smaller About btn, updated title/tagline, +/- toggle icon for Story, tooltip review pass. -->` at the top.
2.  **Title:** Updated `<title>` and `<h1>` to "Terrarium Zero - Version 10.2".
3.  **Tagline:** Updated `<p class="description">` content.
4.  **About Button:** Ensured the smaller CSS style block for `#aboutButton` provided previously is used.
5.  **+/- Toggle:**
    *   Added `<span class="toggle-icon">[-]</span>` within the `<summary>` of the Story Mode panel.
    *   Added CSS for `.toggle-icon`.
    *   Added JavaScript within the `DOMContentLoaded` listener to update the icon text based on the `details` element's `open` state.
6.  **Tooltips:** Reviewed and added/updated `title` attributes for various elements, including panel containers (`#story-mode-panel`, `#controls`, etc.), `details`/`summary` tags, control groups, canvases, legends, log containers, and key data spans, aiming for comprehensive coverage. Minor improvements were made to existing tooltips for clarity where applicable.
7.  **Version Logging:** Updated the initial console log and the System log message during initialization to reflect v10.2.

The core simulation logic remains identical to the previous version (9.8 / 10.2.html file content). Let me know if you'd like any further adjustments!